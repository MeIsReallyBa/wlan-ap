--- a/drivers/net/phy/Kconfig	2023-03-16 09:38:22.742281029 +0800
+++ b/drivers/net/phy/Kconfig	2023-03-16 09:41:46.400370236 +0800
@@ -332,6 +332,10 @@ config RTL8367B_PHY
        tristate "Driver fot the Realtek RTL8367R-VB switch"
        select SWCONFIG

+config RTL8367C_PHY
+       tristate "Driver fot the Realtek RTL8367C/S switch"
+       select SWCONFIG
+
 endif # RTL8366_SMI

 source "drivers/net/phy/b53/Kconfig"

--- a/drivers/net/phy/Makefile	2023-03-16 09:38:12.210161055 +0800
+++ b/drivers/net/phy/Makefile	2023-03-16 09:41:14.548069150 +0800
@@ -34,6 +34,7 @@ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
 obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
 obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
 obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+obj-$(CONFIG_RTL8367C_PHY)	+= rtl8367c.o
 obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
 obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
 obj-$(CONFIG_B53)		+= b53/
--- a/drivers/net/phy/rtl8367c.c	2023-03-16 13:19:40.956555288 +0800
+++ b/drivers/net/phy/rtl8367c.c	2023-03-16 13:12:58.875640407 +0800
@@ -0,0 +1,3402 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/rtl8367c.h>
+
+#include "rtl8366_smi.h"
+
+#define RTL8367C_RESET_DELAY	1000	/* msecs*/
+
+#define RTL8367C_PHY_ADDR_MAX	8
+#define RTL8367C_PHY_REG_MAX	31
+#define RTL8367C_IA_STATUS_REG			0x1f01
+#define   RTL8367C_IA_STATUS_PHY_BUSY		BIT(2)
+#define   RTL8367C_IA_STATUS_SDS_BUSY		BIT(1)
+#define   RTL8367C_IA_STATUS_MDX_BUSY		BIT(0)
+
+#define RTL8367C_IA_ADDRESS_REG			0x1f02
+
+#define RTL8367C_IA_CTRL_REG			0x1f00
+#define   RTL8367C_IA_CTRL_RW(_x)		((_x) << 1)
+#define   RTL8367C_IA_CTRL_RW_READ		RTL8367C_IA_CTRL_RW(0)
+#define   RTL8367C_IA_CTRL_RW_WRITE		RTL8367C_IA_CTRL_RW(1)
+#define   RTL8367C_IA_CTRL_CMD_MASK		BIT(0)
+
+#define    RTL8367C_REG_CHIP_NUMBER    0x1300
+
+#define RTL8367C_INTERNAL_PHY_REG(_a, _r)	(0x2000 + 32 * (_a) + (_r))
+
+#define RTL8367C_CHIP_VER_REG			0x1301
+#define    RTL8367C_REG_VER_MASK    0xf
+#define   RTL8367C_CHIP_VER_RLVID_SHIFT		12
+#define   RTL8367C_CHIP_VER_RLVID_MASK		0xf
+#define   RTL8367C_CHIP_VER_MCID_SHIFT		8
+#define   RTL8367C_CHIP_VER_MCID_MASK		0xf
+#define   RTL8367C_CHIP_VER_BOID_SHIFT		4
+#define   RTL8367C_CHIP_VER_BOID_MASK		0xf
+
+
+
+#define RTL8367C_CHIP_RESET_REG			0x1322
+#define   RTL8367C_CHIP_RESET_SW			BIT(1)
+#define   RTL8367C_CHIP_RESET_HW			BIT(0)
+
+#define RTL8367C_IA_WRITE_DATA_REG		0x1f03
+#define RTL8367C_IA_READ_DATA_REG		0x1f04
+
+#define RTL8367C_REG_MAGIC_ID_REG		0x13c2
+#define   RTL8367C_REG_MAGIC_ID_VAL		0x0249
+
+
+#define    RTL8367C_REG_PORT0_EEECFG    0x0018
+#define    RTL8367C_PORT0_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT0_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT0_EEECFG_EEE_RX_OFFSET    8
+
+
+#define    RTL8367C_REG_MAX_LENGTH_LIMINT_IPG    0x1200
+#define    RTL8367C_MAX_LENTH_CTRL_MASK    0x6000
+#define    RTL8367C_REG_MAX_LEN_RX_TX    0x0884
+#define    RTL8367C_MAX_LEN_RX_TX_MASK    0x3
+#define    RTL8367C_ACL_ACCESS_MODE_MASK    0x1
+
+#define RTL8367C_QOS_RATE_INPUT_MAX_HSG     (0x7FFFF * 8)
+
+#define    RTL8367C_REG_PORT_SECURITY_CTRL    0x08c8
+#define    RTL8367C_PORT_SECURIT_CTRL_REG                        RTL8367C_REG_PORT_SECURITY_CTRL
+#define    RTL8367C_UNKNOWN_UNICAST_DA_BEHAVE_MASK    0xC0
+
+#define    RTL8367C_REG_MIRROR_CTRL2    0x09DA
+#define    RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET    2
+
+#define    RTL8367C_REG_IO_MISC_FUNC    0x1d32
+#define    RTL8367C_INT_EN_OFFSET    1
+
+#define RTK_SWITCH_PORT_NUM (32)
+#define    RTL8367C_REG_PORT0_MISC_CFG    0x000e
+#define    RTL8367C_REG_INGRESSBW_PORT0_RATE_CTRL0    0x000f
+#define    RTL8367C_REG_PORT0_EGRESSBW_CTRL0    0x038c
+#define    RTL8367C_REG_PORT0_EGRESSBW_CTRL1    0x038d
+
+#define RTL8367C_QOS_GRANULARTY_LSB_MASK    0xFFFF
+#define RTL8367C_QOS_GRANULARTY_MSB_MASK    0x70000
+#define RTL8367C_QOS_GRANULARTY_MSB_OFFSET  16
+#define    RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+#define    RTL8367C_PORT6_EGRESSBW_CTRL1_MASK    0x7
+
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+
+#define    RTL8367C_INGRESSBW_PORT_RATE_LSB_BASE                RTL8367C_REG_INGRESSBW_PORT0_RATE_CTRL0
+#define    RTL8367C_PORT_EGRESSBW_LSB_BASE                        RTL8367C_REG_PORT0_EGRESSBW_CTRL0
+#define    RTL8367C_PORT_EGRESSBW_MSB_BASE                        RTL8367C_REG_PORT0_EGRESSBW_CTRL1
+#define    RTL8367C_PORT_MISC_CFG_BASE                            RTL8367C_REG_PORT0_MISC_CFG
+
+#define    RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port)            (RTL8367C_INGRESSBW_PORT_RATE_LSB_BASE + (port << 5))
+#define    RTL8367C_PORT_MISC_CFG_REG(port)                        (RTL8367C_PORT_MISC_CFG_BASE + (port << 5))
+#define    RTL8367C_PORT_EGRESSBW_LSB_REG(port)                    (RTL8367C_PORT_EGRESSBW_LSB_BASE + (port << 1))
+#define    RTL8367C_PORT_EGRESSBW_MSB_REG(port)                    (RTL8367C_PORT_EGRESSBW_MSB_BASE + (port << 1))
+
+
+#define    RTL8367C_REG_SCHEDULE_WFQ_CTRL    0x0300
+#define    RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET    0
+#define    RTL8367C_REG_LUT_CFG    0x0a30
+#define    RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET    3
+
+#define    RTL8367C_REG_RMA_CTRL00    0x0800
+#define    RTL8367C_TRAP_PRIORITY_MASK    0x38
+
+
+#define    RTL8367C_REG_EXT0_RGMXF    0x1306
+#define    RTL8367C_EXT0_RGTX_INV_OFFSET    6
+#define    RTL8367C_REG_EXT1_RGMXF    0x1307
+#define    RTL8367C_EXT1_RGTX_INV_OFFSET    6
+#define    RTL8367C_REG_EXT_TXC_DLY    0x13f9
+#define    RTL8367C_EXT1_GMII_TX_DELAY_OFFSET    12
+#define    RTL8367C_EXT1_GMII_TX_DELAY_MASK    0x7000
+#define    RTL8367C_EXT0_GMII_TX_DELAY_MASK    0xE00
+#define    RTL8367C_REG_BYPASS_LINE_RATE    0x03f7
+#define    RTL8367C_REG_SDS_INDACS_DATA    0x6602
+#define    RTL8367C_REG_SDS_INDACS_ADR    0x6601
+#define    RTL8367C_REG_SDS_INDACS_CMD    0x6600
+#define    RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET    6
+#define    RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET    11
+#define    RTL8367C_REG_DIGITAL_INTERFACE_SELECT    0x1305
+#define    RTL8367C_REG_DIGITAL_INTERFACE_SELECT_1    0x13c3
+#define    RTL8367C_SELECT_GMII_2_MASK    0xF
+#define    RTL8367C_SELECT_GMII_0_MASK    0xF
+
+
+#define RTL8367C_CPU_PORT_NUM		6
+#define RTL8367C_NUM_PORTS		7
+#define RTL8367C_NUM_VLANS		32
+#define RTL8367C_NUM_LEDGROUPS		4
+#define RTL8367C_NUM_VIDS		4096
+#define RTL8367C_PRIORITYMAX		7
+#define RTL8367C_FIDMAX			7
+
+
+#define    RTL8367C_REG_REG_TO_ECO4    0x1d41
+#define    RTL8367C_REG_SDS_MISC    0x1d11
+#define    RTL8367C_CFG_SGMII_FDUP_OFFSET    10
+#define    RTL8367C_CFG_SGMII_SPD_MASK    0x180
+#define    RTL8367C_CFG_SGMII_LINK_OFFSET    9
+#define    RTL8367C_CFG_SGMII_TXFC_OFFSET    13
+#define    RTL8367C_CFG_SGMII_RXFC_OFFSET    14
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE0_FORCE    0x1310
+#define    RTL8367C_REG_DIGITAL_INTERFACE2_FORCE    0x13c4
+
+#define    RTL8367C_REG_CHIP_RESET    0x1322
+#define    RTL8367C_DW8051_RST_OFFSET    4
+#define    RTL8367C_REG_MISCELLANEOUS_CONFIGURE0    0x130c
+#define    RTL8367C_DW8051_EN_OFFSET    5
+
+#define    RTL8367C_REG_DW8051_RDY    0x1336
+#define    RTL8367C_ACS_IROM_ENABLE_OFFSET    1
+#define    RTL8367C_IROM_MSB_OFFSET    2
+
+#define    RTL8367C_REG_PHY_AD    0x130f
+#define    RTL8367C_PDNPHY_OFFSET    5
+#define PHY_RESOLVED_REG                            26
+
+#define PHY_CONTROL_REG                             0
+
+#define    RTL8367C_REG_GPHY_OCP_MSB_0    0x1d15
+#define    RTL8367C_CFG_CPU_OCPADR_MSB_MASK    0xFC0
+#define RTL8367C_PHY_OFFSET             5
+#define RTL8367C_PHY_BASE               0x2000
+#define RTL8367C_PHY_EXT_BASE           0xA000
+
+#define    RTL8367C_REG_ACL_ACCESS_MODE    0x06EB
+#define    RTL8367C_ACL_ACCESS_MODE_OFFSET    0
+#define    RTL8367C_ACL_ACCESS_MODE_MASK    0x1
+
+#define RTL8367C_EXT_RGMXF_REG(_x)		(0x1306 + (_x))
+#define   RTL8367C_EXT_RGMXF_DUMMY0_SHIFT	5
+#define   RTL8367C_EXT_RGMXF_DUMMY0_MASK	0x7ff
+#define   RTL8367C_EXT_RGMXF_TXDELAY_SHIFT	3
+#define   RTL8367C_EXT_RGMXF_TXDELAY_MASK	1
+#define   RTL8367C_EXT_RGMXF_RXDELAY_MASK	0x7
+
+#define    RTL8367C_SELECT_GMII_1_OFFSET    4
+
+#define RTL8367C_VID_MASK	0xffff
+#define RTL8367C_FID_MASK	0xfff
+#define RTL8367C_UNTAG_MASK	0xffff
+#define RTL8367C_MEMBER_MASK	0xffff
+
+
+#define RTL8367C_TA_CTRL_REG			0x0500
+#define   RTL8367C_TA_CTRL_STATUS		BIT(12)
+#define   RTL8367C_TA_CTRL_METHOD		BIT(5)
+#define   RTL8367C_TA_CTRL_CMD_SHIFT		4
+#define   RTL8367C_TA_CTRL_CMD_READ		0
+#define   RTL8367C_TA_CTRL_CMD_WRITE		1
+#define   RTL8367C_TA_CTRL_TABLE_SHIFT		0
+#define   RTL8367C_TA_CTRL_TABLE_ACLRULE		1
+#define   RTL8367C_TA_CTRL_TABLE_ACLACT		2
+#define   RTL8367C_TA_CTRL_TABLE_CVLAN		3
+#define   RTL8367C_TA_CTRL_TABLE_L2		4
+#define   RTL8367C_TA_CTRL_CVLAN_READ \
+		((RTL8367C_TA_CTRL_CMD_READ << RTL8367C_TA_CTRL_CMD_SHIFT) | \
+		 RTL8367C_TA_CTRL_TABLE_CVLAN)
+#define   RTL8367C_TA_CTRL_CVLAN_WRITE \
+		((RTL8367C_TA_CTRL_CMD_WRITE << RTL8367C_TA_CTRL_CMD_SHIFT) | \
+		 RTL8367C_TA_CTRL_TABLE_CVLAN)
+
+#define RTL8367C_TA_ADDR_REG			0x0501
+#define   RTL8367C_TA_ADDR_MASK			0x3fff
+
+#define RTL8367C_TA_DATA_REG(_x)			(0x0503 + (_x))
+#define   RTL8367C_TA_VLAN_DATA_SIZE		4
+#define   RTL8367C_TA_VLAN_VID_MASK		RTL8367C_VID_MASK
+#define   RTL8367C_TA_VLAN_MEMBER_SHIFT		0
+#define   RTL8367C_TA_VLAN_MEMBER_MASK		RTL8367C_MEMBER_MASK
+#define   RTL8367C_TA_VLAN_FID_SHIFT		0
+#define   RTL8367C_TA_VLAN_FID_MASK		RTL8367C_FID_MASK
+#define   RTL8367C_TA_VLAN_UNTAG1_SHIFT		14
+#define   RTL8367C_TA_VLAN_UNTAG1_MASK		0x3
+#define   RTL8367C_TA_VLAN_UNTAG2_SHIFT		0
+#define   RTL8367C_TA_VLAN_UNTAG2_MASK		0x3fff
+
+#define RTL8367C_VLAN_PVID_CTRL_MASK		0x1f
+#define RTL8367C_VLAN_PVID_CTRL_SHIFT(_p)	(8 * ((_p) % 2))
+
+#define RTL8367C_VLAN_MC_BASE(_x)		(0x0728 + (_x) * 4)
+#define   RTL8367C_VLAN_MC_DATA_SIZE		4
+#define   RTL8367C_VLAN_MC_MEMBER_SHIFT		0
+#define   RTL8367C_VLAN_MC_MEMBER_MASK		RTL8367C_MEMBER_MASK
+#define   RTL8367C_VLAN_MC_FID_SHIFT		0
+#define   RTL8367C_VLAN_MC_FID_MASK		RTL8367C_FID_MASK
+#define   RTL8367C_VLAN_MC_EVID_SHIFT		0
+#define   RTL8367C_VLAN_MC_EVID_MASK		RTL8367C_VID_MASK
+
+#define RTL8367C_VLAN_CTRL_REG			0x07a8
+#define   RTL8367C_VLAN_CTRL_ENABLE		BIT(0)
+
+#define RTL8367C_VLAN_INGRESS_REG		0x07a9
+
+#define RTL8367C_MIB_PORT_OFFSET                (0x7C)
+#define RTL8367C_MIB_LEARNENTRYDISCARD_OFFSET   (0x420)
+
+#define    RTL8367C_REG_VLAN_CTRL    0x07a8
+#define    RTL8367C_VLAN_CTRL_OFFSET    0
+#define    RTL8367C_VLAN_CTRL_MASK    0x1
+
+#define RTL8367C_SWC0_REG			0x1200
+#define   RTL8367C_SWC0_MAX_LENGTH_SHIFT		13
+#define   RTL8367C_SWC0_MAX_LENGTH(_x)		((_x) << 13)
+#define   RTL8367C_SWC0_MAX_LENGTH_MASK		RTL8367C_SWC0_MAX_LENGTH(0x3)
+#define   RTL8367C_SWC0_MAX_LENGTH_1522		RTL8367C_SWC0_MAX_LENGTH(0)
+#define   RTL8367C_SWC0_MAX_LENGTH_1536		RTL8367C_SWC0_MAX_LENGTH(1)
+#define   RTL8367C_SWC0_MAX_LENGTH_1552		RTL8367C_SWC0_MAX_LENGTH(2)
+#define   RTL8367C_SWC0_MAX_LENGTH_16000		RTL8367C_SWC0_MAX_LENGTH(3)
+
+
+
+
+#define    RTL8367C_REG_MIB_COUNTER0    0x1000
+
+
+#define    RTL8367C_REG_MIB_ADDRESS    0x1004
+#define    RTL8367C_MIB_ADDRESS_OFFSET    0
+#define    RTL8367C_MIB_ADDRESS_MASK    0x1FF
+
+#define    RTL8367C_REG_MIB_CTRL0    0x1005
+#define    RTL8367C_PORT10_RESET_OFFSET    15
+#define    RTL8367C_PORT10_RESET_MASK    0x8000
+#define    RTL8367C_PORT9_RESET_OFFSET    14
+#define    RTL8367C_PORT9_RESET_MASK    0x4000
+#define    RTL8367C_PORT8_RESET_OFFSET    13
+#define    RTL8367C_PORT8_RESET_MASK    0x2000
+#define    RTL8367C_RESET_VALUE_OFFSET    12
+#define    RTL8367C_RESET_VALUE_MASK    0x1000
+#define    RTL8367C_GLOBAL_RESET_OFFSET    11
+#define    RTL8367C_GLOBAL_RESET_MASK    0x800
+#define    RTL8367C_QM_RESET_OFFSET    10
+#define    RTL8367C_QM_RESET_MASK    0x400
+#define    RTL8367C_PORT7_RESET_OFFSET    9
+#define    RTL8367C_PORT7_RESET_MASK    0x200
+#define    RTL8367C_PORT6_RESET_OFFSET    8
+#define    RTL8367C_PORT6_RESET_MASK    0x100
+#define    RTL8367C_PORT5_RESET_OFFSET    7
+#define    RTL8367C_PORT5_RESET_MASK    0x80
+#define    RTL8367C_PORT4_RESET_OFFSET    6
+#define    RTL8367C_PORT4_RESET_MASK    0x40
+#define    RTL8367C_PORT3_RESET_OFFSET    5
+#define    RTL8367C_PORT3_RESET_MASK    0x20
+#define    RTL8367C_PORT2_RESET_OFFSET    4
+#define    RTL8367C_PORT2_RESET_MASK    0x10
+#define    RTL8367C_PORT1_RESET_OFFSET    3
+#define    RTL8367C_PORT1_RESET_MASK    0x8
+#define    RTL8367C_PORT0_RESET_OFFSET    2
+#define    RTL8367C_PORT0_RESET_MASK    0x4
+#define    RTL8367C_RESET_FLAG_OFFSET    1
+#define    RTL8367C_RESET_FLAG_MASK    0x2
+#define    RTL8367C_MIB_CTRL0_BUSY_FLAG_OFFSET    0
+#define    RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK    0x1
+
+#define	   RTL8367C_MIB_CTRL_REG                                RTL8367C_REG_MIB_CTRL0
+#define    RTL8367C_MIB_PORT07_MASK                                (0xFF<<RTL8367C_PORT0_RESET_OFFSET)
+
+#define    RTL8367C_MIB_COUNTER_BASE_REG                        RTL8367C_REG_MIB_COUNTER0
+
+#define RTL8367C_VLAN_MBRCFG_LEN    (4)
+#define RTL8367C_VLAN_4KTABLE_LEN   (3)
+#define RTK_PHY_PORTMASK_ALL    0xDF  
+
+#define    RTL8367C_REG_TABLE_ACCESS_CTRL    0x0500
+#define    RTL8367C_REG_TABLE_ACCESS_ADDR    0x0501
+#define    RTL8367C_REG_TABLE_WRITE_DATA0    0x0510
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL0    0x0728
+
+#define    RTL8367C_TABLE_ACCESS_WRDATA_BASE                    RTL8367C_REG_TABLE_WRITE_DATA0
+#define    RTL8367C_TABLE_ACCESS_ADDR_REG                        RTL8367C_REG_TABLE_ACCESS_ADDR
+#define    RTL8367C_TABLE_ACCESS_CTRL_REG                        RTL8367C_REG_TABLE_ACCESS_CTRL
+
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE                RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL0
+
+
+#define    RTL8367C_COMMAND_TYPE_MASK    0x8
+#define    RTL8367C_TABLE_TYPE_MASK    0x7
+
+
+#define    RTL8367C_PORT0_VIDX_MASK    0x1F
+#define    RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL0    0x0851
+
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_BASE                RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL0
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL0    0x0700
+#define    RTL8367C_VLAN_PVID_CTRL_BASE                            RTL8367C_REG_VLAN_PVID_CTRL0
+#define    RTL8367C_VLAN_PVID_CTRL_REG(port)                    (RTL8367C_VLAN_PVID_CTRL_BASE + (port >> 1))
+
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_OFFSET(port)        ((port & 0x3) << 2)
+#define    RTL8367C_PORT_VIDX_OFFSET(port)                        ((port &1)<<3)
+#define    RTL8367C_PORT_VIDX_MASK(port)                        (RTL8367C_PORT0_VIDX_MASK << RTL8367C_PORT_VIDX_OFFSET(port))
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port)            (RTL8367C_VLAN_PORTBASED_PRIORITY_BASE + (port >> 2))
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port)            (0x7 << RTL8367C_VLAN_PORTBASED_PRIORITY_OFFSET(port))
+
+
+#define RTL8367C_TABLE_ACCESS_REG_DATA(op, target)    ((op << 3) | target)
+enum RTL8367C_TABLE_ACCESS_OP
+{
+    TB_OP_READ = 0,
+    TB_OP_WRITE
+};
+
+enum RTL8367C_TABLE_ACCESS_TARGET
+{
+    TB_TARGET_ACLRULE = 1,
+    TB_TARGET_ACLACT,
+    TB_TARGET_CVLAN,
+    TB_TARGET_L2,
+    TB_TARGET_IGMP_GROUP
+};
+
+
+#define FIBER2_AUTO_INIT_SIZE 1947
+u8 Fiber2_Auto[FIBER2_AUTO_INIT_SIZE] = {
+0x02,0x05,0x9D,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x06,0xD1,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0x7D,0xD7,0x7C,0x04,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x80,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0x50,0x7D,0x94,0x7C,0xF9,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0x50,0x7D,0x81,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x07,0x50,0x7D,0xA2,0x7C,0x31,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x82,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x60,0x7C,0x69,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0x83,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0x50,0x7D,0x28,0x7C,
+0x97,0x7F,0x02,0x7E,0x66,0x12,0x07,0x50,
+0x7D,0x84,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0x50,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x07,0x50,0x7D,0x85,
+0x7C,0x9D,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0x23,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0x10,0x7C,0xD8,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0x50,0x7D,0x24,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x07,0x50,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,0x50,
+0x7D,0x00,0x7C,0x04,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x50,0x7D,0x2F,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x07,
+0x50,0xE4,0x90,0x06,0x2C,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x07,0x50,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x07,0x50,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x12,0x07,0x80,0x7D,
+0xFE,0x7C,0x00,0x7F,0xAA,0x7E,0x12,0x12,
+0x07,0x50,0x12,0x01,0x27,0x12,0x06,0x29,
+0x12,0x07,0x2F,0x12,0x06,0x8F,0x7D,0x41,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,
+0x50,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0x20,0x7E,0x4E,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xC2,0x00,0xC2,
+0x01,0xD2,0xA9,0xD2,0x8C,0x7F,0x01,0x7E,
+0x62,0x12,0x07,0x0B,0x7F,0x01,0x7E,0x62,
+0x12,0x07,0x0B,0xEF,0x30,0xE2,0x07,0xE4,
+0x90,0x06,0x2C,0xF0,0x80,0xE7,0x90,0x06,
+0x2C,0xE0,0x70,0x12,0x12,0x04,0xF7,0x90,
+0x06,0x2C,0x74,0x01,0xF0,0xE4,0x90,0x06,
+0x33,0xF0,0xA3,0xF0,0x80,0xCF,0xC3,0x90,
+0x06,0x34,0xE0,0x94,0x62,0x90,0x06,0x33,
+0xE0,0x94,0x00,0x40,0xC0,0xE4,0xF0,0xA3,
+0xF0,0x12,0x04,0xF7,0x90,0x06,0x2C,0x74,
+0x01,0xF0,0x80,0xB1,0x7D,0x03,0x7C,0x00,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0x80,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0x50,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x0B,0xEF,0x44,0x40,0xFD,0xAC,0x06,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x03,
+0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x03,0x7C,0x00,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0x80,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0x50,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x0B,0xEF,0x54,0xBF,0xFD,0xAC,0x06,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x03,
+0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,0x80,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,
+0x50,0x7F,0x02,0x7E,0x66,0x12,0x07,0x0B,
+0xEF,0x54,0xFD,0x54,0xFE,0xFD,0xAC,0x06,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0x50,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,0x80,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,
+0x50,0x7F,0x02,0x7E,0x66,0x12,0x07,0x0B,
+0xEF,0x44,0x02,0x44,0x01,0xFD,0xAC,0x06,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0x50,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x02,0x07,0x50,0x75,0x0F,0x80,0x75,
+0x0E,0x7E,0x75,0x0D,0xAA,0x75,0x0C,0x83,
+0xE4,0xF5,0x10,0x7F,0x36,0x7E,0x13,0x12,
+0x07,0x0B,0xEE,0xC4,0xF8,0x54,0xF0,0xC8,
+0xEF,0xC4,0x54,0x0F,0x48,0x54,0x07,0xFB,
+0x7A,0x00,0xEA,0x70,0x4A,0xEB,0x14,0x60,
+0x1C,0x14,0x60,0x27,0x24,0xFE,0x60,0x31,
+0x14,0x60,0x3C,0x24,0x05,0x70,0x38,0x75,
+0x0B,0x00,0x75,0x0A,0xC2,0x75,0x09,0xEB,
+0x75,0x08,0x0B,0x80,0x36,0x75,0x0B,0x40,
+0x75,0x0A,0x59,0x75,0x09,0x73,0x75,0x08,
+0x07,0x80,0x28,0x75,0x0B,0x00,0x75,0x0A,
+0xE1,0x75,0x09,0xF5,0x75,0x08,0x05,0x80,
+0x1A,0x75,0x0B,0xA0,0x75,0x0A,0xAC,0x75,
+0x09,0xB9,0x75,0x08,0x03,0x80,0x0C,0x75,
+0x0B,0x00,0x75,0x0A,0x62,0x75,0x09,0x3D,
+0x75,0x08,0x01,0x75,0x89,0x11,0xE4,0x7B,
+0x60,0x7A,0x09,0xF9,0xF8,0xAF,0x0B,0xAE,
+0x0A,0xAD,0x09,0xAC,0x08,0x12,0x00,0x60,
+0xAA,0x06,0xAB,0x07,0xC3,0xE4,0x9B,0xFB,
+0xE4,0x9A,0xFA,0x78,0x17,0xF6,0xAF,0x03,
+0xEF,0x08,0xF6,0x18,0xE6,0xF5,0x8C,0x08,
+0xE6,0xF5,0x8A,0x74,0x0D,0x2B,0xFB,0xE4,
+0x3A,0x18,0xF6,0xAF,0x03,0xEF,0x08,0xF6,
+0x75,0x88,0x10,0x53,0x8E,0xC7,0xD2,0xA9,
+0x22,0x7D,0x02,0x7C,0x00,0x7F,0x4A,0x7E,
+0x13,0x12,0x07,0x50,0x7D,0x46,0x7C,0x71,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0x50,0xE4,0xFF,0xFE,
+0x0F,0xBF,0x00,0x01,0x0E,0xEF,0x64,0x64,
+0x4E,0x70,0xF5,0x7D,0x04,0x7C,0x00,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x00,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0xE4,0xFD,0xFC,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x00,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0xE4,0xFD,0xFC,0x7F,
+0x4A,0x7E,0x13,0x12,0x07,0x50,0x7D,0x06,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0x50,0x78,
+0x7F,0xE4,0xF6,0xD8,0xFD,0x75,0x81,0x3C,
+0x02,0x05,0xE4,0x02,0x02,0x2F,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0x40,0x03,0xF6,
+0x80,0x01,0xF2,0x08,0xDF,0xF4,0x80,0x29,
+0xE4,0x93,0xA3,0xF8,0x54,0x07,0x24,0x0C,
+0xC8,0xC3,0x33,0xC4,0x54,0x0F,0x44,0x20,
+0xC8,0x83,0x40,0x04,0xF4,0x56,0x80,0x01,
+0x46,0xF6,0xDF,0xE4,0x80,0x0B,0x01,0x02,
+0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x07,
+0x8C,0xE4,0x7E,0x01,0x93,0x60,0xBC,0xA3,
+0xFF,0x54,0x3F,0x30,0xE5,0x09,0x54,0x1F,
+0xFE,0xE4,0x93,0xA3,0x60,0x01,0x0E,0xCF,
+0x54,0xC0,0x25,0xE0,0x60,0xA8,0x40,0xB8,
+0xE4,0x93,0xA3,0xFA,0xE4,0x93,0xA3,0xF8,
+0xE4,0x93,0xA3,0xC8,0xC5,0x82,0xC8,0xCA,
+0xC5,0x83,0xCA,0xF0,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xDF,0xE9,0xDE,
+0xE7,0x80,0xBE,0x7D,0xD7,0x7C,0x04,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x50,0x7D,0x80,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0x50,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x40,0x7C,0x17,
+0x7F,0x11,0x7E,0x1D,0x12,0x07,0x50,0x7F,
+0x41,0x7E,0x1D,0x12,0x07,0x0B,0xEF,0x44,
+0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,
+0x7E,0x1D,0x12,0x07,0x50,0x7D,0xBB,0x7C,
+0x15,0x7F,0xEB,0x7E,0x13,0x12,0x07,0x50,
+0x7D,0x07,0x7C,0x00,0x7F,0xE7,0x7E,0x13,
+0x12,0x07,0x50,0x7D,0x40,0x7C,0x11,0x7F,
+0x00,0x7E,0x62,0x12,0x07,0x50,0x02,0x03,
+0x32,0x7D,0x04,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0x50,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0x0B,0xEF,0x44,
+0x02,0x44,0x04,0xFD,0xAC,0x06,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0x50,0x7D,0x04,0x7C,
+0x00,0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x02,0x07,0x50,0xC0,0xE0,0xC0,0xF0,0xC0,
+0x83,0xC0,0x82,0xC0,0xD0,0x75,0xD0,0x00,
+0xC0,0x00,0x78,0x17,0xE6,0xF5,0x8C,0x78,
+0x18,0xE6,0xF5,0x8A,0x90,0x06,0x31,0xE4,
+0x75,0xF0,0x01,0x12,0x00,0x0E,0x90,0x06,
+0x33,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0xD0,0x00,0xD0,0xD0,0xD0,0x82,0xD0,0x83,
+0xD0,0xF0,0xD0,0xE0,0x32,0xC2,0xAF,0xAD,
+0x07,0xAC,0x06,0x8C,0xA2,0x8D,0xA3,0x75,
+0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0xAE,0xA1,0xBE,
+0x00,0xF0,0xAE,0xA6,0xAF,0xA7,0xD2,0xAF,
+0x22,0x7D,0x20,0x7C,0x0F,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x50,0x7D,0x01,0x7C,0x00,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0x50,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,
+0x07,0x50,0xC2,0xAF,0xAB,0x07,0xAA,0x06,
+0x8A,0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,0xA5,
+0x75,0xA0,0x03,0x00,0x00,0x00,0xAA,0xA1,
+0xBA,0x00,0xF8,0xD2,0xAF,0x22,0x7F,0x0C,
+0x7E,0x13,0x12,0x07,0x0B,0xEF,0x44,0x50,
+0xFD,0xAC,0x06,0x7F,0x0C,0x7E,0x13,0x02,
+0x07,0x50,0x12,0x07,0x6C,0x12,0x07,0x97,
+0x12,0x04,0x32,0x02,0x00,0x03,0x42,0x06,
+0x33,0x00,0x00,0x42,0x06,0x31,0x00,0x00,
+0x00,0xE4,0xF5,0x8E,0x22};
+
+#define FIBER2_1G_INIT_SIZE 1842
+u8 Fiber2_1G[FIBER2_1G_INIT_SIZE] = {
+0x02,0x05,0x97,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x06,0x89,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0x7D,0xD7,0x7C,0x04,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x94,0x7C,0xF9,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x81,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xA2,0x7C,0x31,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x82,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x60,0x7C,0x69,
+0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x83,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x28,0x7C,
+0x97,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x84,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x85,
+0x7C,0x9D,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x23,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x10,0x7C,0xD8,0x7F,0x02,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x24,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x2F,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,
+0x40,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,
+0xBF,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,0xFD,
+0x54,0xFE,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,0x02,
+0x44,0x01,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0xE4,0x90,0x06,0x2C,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x06,0xE7,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x12,0x07,0x17,0x7D,
+0xFE,0x7C,0x00,0x7F,0xAA,0x7E,0x12,0x12,
+0x06,0xE7,0x12,0x01,0x27,0x12,0x06,0x23,
+0x7D,0x41,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xC2,
+0x00,0xC2,0x01,0xD2,0xA9,0xD2,0x8C,0x7F,
+0x01,0x7E,0x62,0x12,0x06,0xC3,0x7F,0x01,
+0x7E,0x62,0x12,0x06,0xC3,0xEF,0x30,0xE2,
+0x07,0xE4,0x90,0x06,0x2C,0xF0,0x80,0xE7,
+0x90,0x06,0x2C,0xE0,0x70,0x12,0x12,0x04,
+0xF1,0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,
+0x90,0x06,0x33,0xF0,0xA3,0xF0,0x80,0xCF,
+0xC3,0x90,0x06,0x34,0xE0,0x94,0x62,0x90,
+0x06,0x33,0xE0,0x94,0x00,0x40,0xC0,0xE4,
+0xF0,0xA3,0xF0,0x12,0x04,0xF1,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0x80,0xB1,0x75,0x0F,
+0x80,0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,
+0x0C,0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,
+0x13,0x12,0x06,0xC3,0xEE,0xC4,0xF8,0x54,
+0xF0,0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,
+0x07,0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,
+0x14,0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,
+0x60,0x31,0x14,0x60,0x3C,0x24,0x05,0x70,
+0x38,0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,
+0x09,0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,
+0x0B,0x40,0x75,0x0A,0x59,0x75,0x09,0x73,
+0x75,0x08,0x07,0x80,0x28,0x75,0x0B,0x00,
+0x75,0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,
+0x05,0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,
+0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,0x80,
+0x0C,0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,
+0x09,0x3D,0x75,0x08,0x01,0x75,0x89,0x11,
+0xE4,0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,
+0x0B,0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,
+0x00,0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,
+0x9B,0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,
+0xAF,0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,
+0x8C,0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,
+0xFB,0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,
+0xD2,0xA9,0x22,0x7D,0x02,0x7C,0x00,0x7F,
+0x4A,0x7E,0x13,0x12,0x06,0xE7,0x7D,0x46,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,
+0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,
+0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,
+0x00,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x4A,0x7E,0x13,0x12,0x06,0xE7,
+0x7D,0x06,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x05,0xDE,0x02,0x03,0x2F,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x07,0x23,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x7D,0xD7,0x7C,
+0x04,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x80,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x40,
+0x7C,0x17,0x7F,0x11,0x7E,0x1D,0x12,0x06,
+0xE7,0x7D,0xBB,0x7C,0x15,0x7F,0xEB,0x7E,
+0x13,0x12,0x06,0xE7,0x7D,0x0C,0x7C,0x00,
+0x7F,0xE7,0x7E,0x13,0x12,0x06,0xE7,0x7F,
+0x41,0x7E,0x1D,0x12,0x06,0xC3,0xEF,0x44,
+0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,
+0x7E,0x1D,0x12,0x06,0xE7,0x7D,0x40,0x7C,
+0x01,0x7F,0x00,0x7E,0x62,0x12,0x06,0xE7,
+0x02,0x02,0x2F,0xC0,0xE0,0xC0,0xF0,0xC0,
+0x83,0xC0,0x82,0xC0,0xD0,0x75,0xD0,0x00,
+0xC0,0x00,0x78,0x17,0xE6,0xF5,0x8C,0x78,
+0x18,0xE6,0xF5,0x8A,0x90,0x06,0x31,0xE4,
+0x75,0xF0,0x01,0x12,0x00,0x0E,0x90,0x06,
+0x33,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0xD0,0x00,0xD0,0xD0,0xD0,0x82,0xD0,0x83,
+0xD0,0xF0,0xD0,0xE0,0x32,0xC2,0xAF,0xAD,
+0x07,0xAC,0x06,0x8C,0xA2,0x8D,0xA3,0x75,
+0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0xAE,0xA1,0xBE,
+0x00,0xF0,0xAE,0xA6,0xAF,0xA7,0xD2,0xAF,
+0x22,0xC2,0xAF,0xAB,0x07,0xAA,0x06,0x8A,
+0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,0xA5,0x75,
+0xA0,0x03,0x00,0x00,0x00,0xAA,0xA1,0xBA,
+0x00,0xF8,0xD2,0xAF,0x22,0x7F,0x0C,0x7E,
+0x13,0x12,0x06,0xC3,0xEF,0x44,0x50,0xFD,
+0xAC,0x06,0x7F,0x0C,0x7E,0x13,0x02,0x06,
+0xE7,0x12,0x07,0x03,0x12,0x07,0x2E,0x12,
+0x04,0x2C,0x02,0x00,0x03,0x42,0x06,0x33,
+0x00,0x00,0x42,0x06,0x31,0x00,0x00,0x00,
+0xE4,0xF5,0x8E,0x22};
+
+#define FIBER2_100M_INIT_SIZE 1842
+u8 Fiber2_100M[FIBER2_100M_INIT_SIZE] = {
+0x02,0x05,0x97,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x06,0x89,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0x7D,0xD7,0x7C,0x04,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x94,0x7C,0xF9,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x81,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xA2,0x7C,0x31,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x82,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x60,0x7C,0x69,
+0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x83,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x28,0x7C,
+0x97,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x84,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x85,
+0x7C,0x9D,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x23,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x10,0x7C,0xD8,0x7F,0x02,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x24,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x2F,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,
+0x40,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,
+0xBF,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,0xFD,
+0x54,0xFE,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,0x02,
+0x44,0x01,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0xE4,0x90,0x06,0x2C,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x06,0xE7,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x12,0x07,0x17,0x7D,
+0xFE,0x7C,0x00,0x7F,0xAA,0x7E,0x12,0x12,
+0x06,0xE7,0x12,0x01,0x27,0x12,0x06,0x23,
+0x7D,0x41,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xC2,
+0x00,0xC2,0x01,0xD2,0xA9,0xD2,0x8C,0x7F,
+0x01,0x7E,0x62,0x12,0x06,0xC3,0x7F,0x01,
+0x7E,0x62,0x12,0x06,0xC3,0xEF,0x30,0xE2,
+0x07,0xE4,0x90,0x06,0x2C,0xF0,0x80,0xE7,
+0x90,0x06,0x2C,0xE0,0x70,0x12,0x12,0x04,
+0xF1,0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,
+0x90,0x06,0x33,0xF0,0xA3,0xF0,0x80,0xCF,
+0xC3,0x90,0x06,0x34,0xE0,0x94,0x62,0x90,
+0x06,0x33,0xE0,0x94,0x00,0x40,0xC0,0xE4,
+0xF0,0xA3,0xF0,0x12,0x04,0xF1,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0x80,0xB1,0x75,0x0F,
+0x80,0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,
+0x0C,0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,
+0x13,0x12,0x06,0xC3,0xEE,0xC4,0xF8,0x54,
+0xF0,0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,
+0x07,0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,
+0x14,0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,
+0x60,0x31,0x14,0x60,0x3C,0x24,0x05,0x70,
+0x38,0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,
+0x09,0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,
+0x0B,0x40,0x75,0x0A,0x59,0x75,0x09,0x73,
+0x75,0x08,0x07,0x80,0x28,0x75,0x0B,0x00,
+0x75,0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,
+0x05,0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,
+0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,0x80,
+0x0C,0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,
+0x09,0x3D,0x75,0x08,0x01,0x75,0x89,0x11,
+0xE4,0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,
+0x0B,0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,
+0x00,0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,
+0x9B,0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,
+0xAF,0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,
+0x8C,0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,
+0xFB,0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,
+0xD2,0xA9,0x22,0x7D,0x02,0x7C,0x00,0x7F,
+0x4A,0x7E,0x13,0x12,0x06,0xE7,0x7D,0x46,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,
+0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,
+0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,
+0x00,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x4A,0x7E,0x13,0x12,0x06,0xE7,
+0x7D,0x06,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x05,0xDE,0x02,0x03,0x2F,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x07,0x23,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x7D,0xD7,0x7C,
+0x24,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x80,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x16,0x7F,0x11,0x7E,0x1D,0x12,0x06,
+0xE7,0x7D,0xBB,0x7C,0x15,0x7F,0xEB,0x7E,
+0x13,0x12,0x06,0xE7,0x7D,0x0D,0x7C,0x00,
+0x7F,0xE7,0x7E,0x13,0x12,0x06,0xE7,0x7F,
+0x41,0x7E,0x1D,0x12,0x06,0xC3,0xEF,0x44,
+0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,
+0x7E,0x1D,0x12,0x06,0xE7,0x7D,0x00,0x7C,
+0x21,0x7F,0x00,0x7E,0x62,0x12,0x06,0xE7,
+0x02,0x02,0x2F,0xC0,0xE0,0xC0,0xF0,0xC0,
+0x83,0xC0,0x82,0xC0,0xD0,0x75,0xD0,0x00,
+0xC0,0x00,0x78,0x17,0xE6,0xF5,0x8C,0x78,
+0x18,0xE6,0xF5,0x8A,0x90,0x06,0x31,0xE4,
+0x75,0xF0,0x01,0x12,0x00,0x0E,0x90,0x06,
+0x33,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0xD0,0x00,0xD0,0xD0,0xD0,0x82,0xD0,0x83,
+0xD0,0xF0,0xD0,0xE0,0x32,0xC2,0xAF,0xAD,
+0x07,0xAC,0x06,0x8C,0xA2,0x8D,0xA3,0x75,
+0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0xAE,0xA1,0xBE,
+0x00,0xF0,0xAE,0xA6,0xAF,0xA7,0xD2,0xAF,
+0x22,0xC2,0xAF,0xAB,0x07,0xAA,0x06,0x8A,
+0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,0xA5,0x75,
+0xA0,0x03,0x00,0x00,0x00,0xAA,0xA1,0xBA,
+0x00,0xF8,0xD2,0xAF,0x22,0x7F,0x0C,0x7E,
+0x13,0x12,0x06,0xC3,0xEF,0x44,0x50,0xFD,
+0xAC,0x06,0x7F,0x0C,0x7E,0x13,0x02,0x06,
+0xE7,0x12,0x07,0x03,0x12,0x07,0x2E,0x12,
+0x04,0x2C,0x02,0x00,0x03,0x42,0x06,0x33,
+0x00,0x00,0x42,0x06,0x31,0x00,0x00,0x00,
+0xE4,0xF5,0x8E,0x22};
+
+
+#define SGMII_INIT_SIZE 1223
+u8 Sgmii_Init[SGMII_INIT_SIZE] = {
+0x02,0x03,0xA9,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x04,0x35,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0xE4,0x90,0x06,0x28,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x04,0x93,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x04,0x93,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,
+0x49,0x7E,0x13,0x12,0x04,0x93,0x12,0x04,
+0xBA,0x7D,0xFE,0x7C,0x00,0x7F,0xAA,0x7E,
+0x12,0x12,0x04,0x93,0x7D,0x41,0x7C,0x00,
+0x7F,0x36,0x7E,0x13,0x12,0x04,0x93,0xE4,
+0xFF,0xFE,0xFD,0x80,0x25,0xE4,0x7F,0x20,
+0x7E,0x4E,0xFD,0xFC,0x90,0x06,0x24,0x12,
+0x01,0x0F,0xC3,0x12,0x00,0xF2,0x50,0x1B,
+0x90,0x06,0x24,0x12,0x01,0x03,0xEF,0x24,
+0x01,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,0xFD,
+0xE4,0x3C,0xFC,0x90,0x06,0x24,0x12,0x01,
+0x1B,0x80,0xD2,0xC2,0x00,0xC2,0x01,0xD2,
+0xA9,0xD2,0x8C,0x7D,0x3D,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x93,0x7D,0x80,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,
+0x93,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6F,
+0x7F,0x02,0x7E,0x66,0x12,0x04,0x6F,0xEF,
+0x30,0xE4,0x07,0xE4,0x90,0x06,0x28,0xF0,
+0x80,0xD1,0x90,0x06,0x28,0xE0,0x70,0x12,
+0x12,0x03,0x03,0x90,0x06,0x28,0x74,0x01,
+0xF0,0xE4,0x90,0x06,0x2B,0xF0,0xA3,0xF0,
+0x80,0xB9,0xC3,0x90,0x06,0x2C,0xE0,0x94,
+0x62,0x90,0x06,0x2B,0xE0,0x94,0x00,0x40,
+0xAA,0xE4,0xF0,0xA3,0xF0,0x12,0x03,0x03,
+0x90,0x06,0x28,0x74,0x01,0xF0,0x80,0x9B,
+0x75,0x0F,0x80,0x75,0x0E,0x7E,0x75,0x0D,
+0xAA,0x75,0x0C,0x83,0xE4,0xF5,0x10,0x7F,
+0x36,0x7E,0x13,0x12,0x04,0x6F,0xEE,0xC4,
+0xF8,0x54,0xF0,0xC8,0xEF,0xC4,0x54,0x0F,
+0x48,0x54,0x07,0xFB,0x7A,0x00,0xEA,0x70,
+0x4A,0xEB,0x14,0x60,0x1C,0x14,0x60,0x27,
+0x24,0xFE,0x60,0x31,0x14,0x60,0x3C,0x24,
+0x05,0x70,0x38,0x75,0x0B,0x00,0x75,0x0A,
+0xC2,0x75,0x09,0xEB,0x75,0x08,0x0B,0x80,
+0x36,0x75,0x0B,0x40,0x75,0x0A,0x59,0x75,
+0x09,0x73,0x75,0x08,0x07,0x80,0x28,0x75,
+0x0B,0x00,0x75,0x0A,0xE1,0x75,0x09,0xF5,
+0x75,0x08,0x05,0x80,0x1A,0x75,0x0B,0xA0,
+0x75,0x0A,0xAC,0x75,0x09,0xB9,0x75,0x08,
+0x03,0x80,0x0C,0x75,0x0B,0x00,0x75,0x0A,
+0x62,0x75,0x09,0x3D,0x75,0x08,0x01,0x75,
+0x89,0x11,0xE4,0x7B,0x60,0x7A,0x09,0xF9,
+0xF8,0xAF,0x0B,0xAE,0x0A,0xAD,0x09,0xAC,
+0x08,0x12,0x00,0x60,0xAA,0x06,0xAB,0x07,
+0xC3,0xE4,0x9B,0xFB,0xE4,0x9A,0xFA,0x78,
+0x17,0xF6,0xAF,0x03,0xEF,0x08,0xF6,0x18,
+0xE6,0xF5,0x8C,0x08,0xE6,0xF5,0x8A,0x74,
+0x0D,0x2B,0xFB,0xE4,0x3A,0x18,0xF6,0xAF,
+0x03,0xEF,0x08,0xF6,0x75,0x88,0x10,0x53,
+0x8E,0xC7,0xD2,0xA9,0x22,0x7D,0x02,0x7C,
+0x00,0x7F,0x4A,0x7E,0x13,0x12,0x04,0x93,
+0x7D,0x46,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x04,0x93,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,
+0x93,0xE4,0xFF,0xFE,0x0F,0xBF,0x00,0x01,
+0x0E,0xEF,0x64,0x64,0x4E,0x70,0xF5,0x7D,
+0x04,0x7C,0x00,0x7F,0x02,0x7E,0x66,0x12,
+0x04,0x93,0x7D,0x00,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,0x93,
+0xE4,0xFD,0xFC,0x7F,0x02,0x7E,0x66,0x12,
+0x04,0x93,0x7D,0x00,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,0x93,
+0xE4,0xFD,0xFC,0x7F,0x4A,0x7E,0x13,0x12,
+0x04,0x93,0x7D,0x06,0x7C,0x71,0x7F,0x02,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0x03,0x7C,
+0x00,0x7F,0x01,0x7E,0x66,0x12,0x04,0x93,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x02,0x04,0x93,0x78,0x7F,0xE4,0xF6,0xD8,
+0xFD,0x75,0x81,0x3C,0x02,0x03,0xF0,0x02,
+0x01,0x27,0xE4,0x93,0xA3,0xF8,0xE4,0x93,
+0xA3,0x40,0x03,0xF6,0x80,0x01,0xF2,0x08,
+0xDF,0xF4,0x80,0x29,0xE4,0x93,0xA3,0xF8,
+0x54,0x07,0x24,0x0C,0xC8,0xC3,0x33,0xC4,
+0x54,0x0F,0x44,0x20,0xC8,0x83,0x40,0x04,
+0xF4,0x56,0x80,0x01,0x46,0xF6,0xDF,0xE4,
+0x80,0x0B,0x01,0x02,0x04,0x08,0x10,0x20,
+0x40,0x80,0x90,0x04,0xAF,0xE4,0x7E,0x01,
+0x93,0x60,0xBC,0xA3,0xFF,0x54,0x3F,0x30,
+0xE5,0x09,0x54,0x1F,0xFE,0xE4,0x93,0xA3,
+0x60,0x01,0x0E,0xCF,0x54,0xC0,0x25,0xE0,
+0x60,0xA8,0x40,0xB8,0xE4,0x93,0xA3,0xFA,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xF0,
+0xA3,0xC8,0xC5,0x82,0xC8,0xCA,0xC5,0x83,
+0xCA,0xDF,0xE9,0xDE,0xE7,0x80,0xBE,0xC0,
+0xE0,0xC0,0xF0,0xC0,0x83,0xC0,0x82,0xC0,
+0xD0,0x75,0xD0,0x00,0xC0,0x00,0x78,0x17,
+0xE6,0xF5,0x8C,0x78,0x18,0xE6,0xF5,0x8A,
+0x90,0x06,0x29,0xE4,0x75,0xF0,0x01,0x12,
+0x00,0x0E,0x90,0x06,0x2B,0xE4,0x75,0xF0,
+0x01,0x12,0x00,0x0E,0xD0,0x00,0xD0,0xD0,
+0xD0,0x82,0xD0,0x83,0xD0,0xF0,0xD0,0xE0,
+0x32,0xC2,0xAF,0xAD,0x07,0xAC,0x06,0x8C,
+0xA2,0x8D,0xA3,0x75,0xA0,0x01,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0xAE,0xA1,0xBE,0x00,0xF0,0xAE,0xA6,
+0xAF,0xA7,0xD2,0xAF,0x22,0xC2,0xAF,0xAB,
+0x07,0xAA,0x06,0x8A,0xA2,0x8B,0xA3,0x8C,
+0xA4,0x8D,0xA5,0x75,0xA0,0x03,0x00,0x00,
+0x00,0xAA,0xA1,0xBA,0x00,0xF8,0xD2,0xAF,
+0x22,0x42,0x06,0x2B,0x00,0x00,0x42,0x06,
+0x29,0x00,0x00,0x00,0x12,0x04,0xC3,0x12,
+0x02,0x3E,0x02,0x00,0x03,0xE4,0xF5,0x8E,
+0x22};
+
+#define FIBER1_2_INIT_SIZE 1332
+u8 Fiber1_2_Init[FIBER1_2_INIT_SIZE] = {
+0x02,0x05,0x28,0x90,0x00,0x0A,0xEE,0xF0,
+0xA3,0xEF,0xF0,0xE4,0x7F,0x11,0x7E,0x62,
+0x12,0x04,0xF7,0x7F,0x11,0x7E,0x62,0x12,
+0x04,0xF7,0xEF,0x30,0xE2,0x03,0x02,0x01,
+0xA8,0x90,0x00,0x0B,0xE0,0x04,0xF0,0x70,
+0x06,0x90,0x00,0x0A,0xE0,0x04,0xF0,0x90,
+0x00,0x0A,0xE0,0xFC,0xA3,0xE0,0xFD,0x7F,
+0xA4,0x7E,0x0B,0x12,0x04,0xDB,0x7D,0x66,
+0x7C,0x00,0x7F,0x11,0x7E,0x13,0x12,0x04,
+0xDB,0x7D,0x66,0x7C,0x10,0x7F,0x11,0x7E,
+0x13,0x12,0x04,0xDB,0x7F,0x9D,0x7E,0x1D,
+0x12,0x04,0xF7,0xEE,0x30,0xE0,0xF5,0xE4,
+0x90,0x00,0x0C,0xF0,0xA3,0xF0,0x90,0x00,
+0x0D,0xE0,0x04,0xF0,0x70,0x06,0x90,0x00,
+0x0C,0xE0,0x04,0xF0,0x90,0x00,0x0C,0xE0,
+0xB4,0x0B,0xEB,0xA3,0xE0,0xB4,0xB8,0xE6,
+0x7D,0x02,0x7C,0x00,0x7F,0x3D,0x7E,0x13,
+0x12,0x04,0xDB,0xE4,0x90,0x00,0x0C,0xF0,
+0xA3,0xF0,0x90,0x00,0x0D,0xE0,0x04,0xF0,
+0x70,0x06,0x90,0x00,0x0C,0xE0,0x04,0xF0,
+0x90,0x00,0x0C,0xE0,0xB4,0x0B,0xEB,0xA3,
+0xE0,0xB4,0xB8,0xE6,0x90,0x00,0x14,0x74,
+0x14,0xF0,0xA3,0xE4,0xF0,0xFB,0xFA,0xFD,
+0xFC,0x7F,0x01,0xFE,0x12,0x04,0x2D,0xE4,
+0x90,0x00,0x0C,0xF0,0xA3,0xF0,0x90,0x00,
+0x0C,0xE0,0xFE,0xA3,0xE0,0xFF,0xE4,0xFC,
+0xFD,0x7B,0x60,0x7A,0xEA,0xF9,0xF8,0xD3,
+0x12,0x05,0x12,0x40,0x10,0x90,0x00,0x0D,
+0xE0,0x04,0xF0,0x70,0x06,0x90,0x00,0x0C,
+0xE0,0x04,0xF0,0x80,0xD9,0xE4,0x90,0x00,
+0x0C,0xF0,0xA3,0xF0,0x90,0x00,0x0C,0xE0,
+0xFE,0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,0x7B,
+0x60,0x7A,0xEA,0xF9,0xF8,0xD3,0x12,0x05,
+0x12,0x40,0x10,0x90,0x00,0x0D,0xE0,0x04,
+0xF0,0x70,0x06,0x90,0x00,0x0C,0xE0,0x04,
+0xF0,0x80,0xD9,0x90,0x00,0x14,0x74,0x14,
+0xF0,0xA3,0x74,0x03,0xF0,0xE4,0xFB,0xFA,
+0xFD,0xFC,0x7F,0x01,0xFE,0x12,0x04,0x2D,
+0xE4,0x90,0x00,0x0C,0xF0,0xA3,0xF0,0x90,
+0x00,0x0D,0xE0,0x04,0xF0,0x70,0x06,0x90,
+0x00,0x0C,0xE0,0x04,0xF0,0x90,0x00,0x0C,
+0xE0,0xB4,0x75,0xEB,0xA3,0xE0,0xB4,0x30,
+0xE6,0xE4,0x90,0x00,0x0C,0xF0,0xA3,0xF0,
+0x90,0x00,0x0D,0xE0,0x04,0xF0,0x70,0x06,
+0x90,0x00,0x0C,0xE0,0x04,0xF0,0x90,0x00,
+0x0C,0xE0,0xB4,0x75,0xEB,0xA3,0xE0,0xB4,
+0x30,0xE6,0xE4,0xFD,0xFC,0x7F,0x3D,0x7E,
+0x13,0x12,0x04,0xDB,0xE4,0x90,0x00,0x0C,
+0xF0,0xA3,0xF0,0x90,0x00,0x0D,0xE0,0x04,
+0xF0,0x70,0x06,0x90,0x00,0x0C,0xE0,0x04,
+0xF0,0x90,0x00,0x0C,0xE0,0xB4,0x0B,0xEB,
+0xA3,0xE0,0xB4,0xB8,0xE6,0x7D,0x66,0x7C,
+0x00,0x7F,0x11,0x7E,0x13,0x12,0x04,0xDB,
+0x22,0x90,0x00,0x0A,0xEE,0xF0,0xA3,0xEF,
+0xF0,0xE4,0xFF,0x0F,0x7E,0x62,0x12,0x04,
+0xF7,0x7F,0x01,0x7E,0x62,0x12,0x04,0xF7,
+0xEF,0x30,0xE2,0x03,0x02,0x03,0x4C,0x90,
+0x00,0x0B,0xE0,0x04,0xF0,0x70,0x06,0x90,
+0x00,0x0A,0xE0,0x04,0xF0,0x90,0x00,0x0A,
+0xE0,0xFC,0xA3,0xE0,0xFD,0x7F,0xA3,0x7E,
+0x0B,0x12,0x04,0xDB,0x7D,0x66,0x7C,0x00,
+0x7F,0xC4,0x7E,0x13,0x12,0x04,0xDB,0x7D,
+0x66,0x7C,0x10,0x7F,0xC4,0x7E,0x13,0x12,
+0x04,0xDB,0x7F,0x9D,0x7E,0x1D,0x12,0x04,
+0xF7,0xEE,0x30,0xE1,0xF5,0xE4,0x90,0x00,
+0x0C,0xF0,0xA3,0xF0,0x90,0x00,0x0D,0xE0,
+0x04,0xF0,0x70,0x06,0x90,0x00,0x0C,0xE0,
+0x04,0xF0,0x90,0x00,0x0C,0xE0,0xB4,0x0B,
+0xEB,0xA3,0xE0,0xB4,0xB8,0xE6,0x7D,0x02,
+0x7C,0x00,0x7F,0x3D,0x7E,0x13,0x12,0x04,
+0xDB,0xE4,0x90,0x00,0x0C,0xF0,0xA3,0xF0,
+0x90,0x00,0x0D,0xE0,0x04,0xF0,0x70,0x06,
+0x90,0x00,0x0C,0xE0,0x04,0xF0,0x90,0x00,
+0x0C,0xE0,0xB4,0x0B,0xEB,0xA3,0xE0,0xB4,
+0xB8,0xE6,0x90,0x00,0x14,0x74,0x14,0xF0,
+0xA3,0xE4,0xF0,0xFB,0xFA,0xFD,0xFC,0xFF,
+0xFE,0x12,0x04,0x2D,0xE4,0x90,0x00,0x0C,
+0xF0,0xA3,0xF0,0x90,0x00,0x0C,0xE0,0xFE,
+0xA3,0xE0,0xFF,0xE4,0xFC,0xFD,0x7B,0x60,
+0x7A,0xEA,0xF9,0xF8,0xD3,0x12,0x05,0x12,
+0x40,0x10,0x90,0x00,0x0D,0xE0,0x04,0xF0,
+0x70,0x06,0x90,0x00,0x0C,0xE0,0x04,0xF0,
+0x80,0xD9,0xE4,0x90,0x00,0x0C,0xF0,0xA3,
+0xF0,0x90,0x00,0x0C,0xE0,0xFE,0xA3,0xE0,
+0xFF,0xE4,0xFC,0xFD,0x7B,0x60,0x7A,0xEA,
+0xF9,0xF8,0xD3,0x12,0x05,0x12,0x40,0x10,
+0x90,0x00,0x0D,0xE0,0x04,0xF0,0x70,0x06,
+0x90,0x00,0x0C,0xE0,0x04,0xF0,0x80,0xD9,
+0x90,0x00,0x14,0x74,0x14,0xF0,0xA3,0x74,
+0x03,0xF0,0xE4,0xFB,0xFA,0xFD,0xFC,0xFF,
+0xFE,0x12,0x04,0x2D,0xE4,0x90,0x00,0x0C,
+0xF0,0xA3,0xF0,0x90,0x00,0x0D,0xE0,0x04,
+0xF0,0x70,0x06,0x90,0x00,0x0C,0xE0,0x04,
+0xF0,0x90,0x00,0x0C,0xE0,0xB4,0x75,0xEB,
+0xA3,0xE0,0xB4,0x30,0xE6,0xE4,0x90,0x00,
+0x0C,0xF0,0xA3,0xF0,0x90,0x00,0x0D,0xE0,
+0x04,0xF0,0x70,0x06,0x90,0x00,0x0C,0xE0,
+0x04,0xF0,0x90,0x00,0x0C,0xE0,0xB4,0x75,
+0xEB,0xA3,0xE0,0xB4,0x30,0xE6,0xE4,0xFD,
+0xFC,0x7F,0x3D,0x7E,0x13,0x12,0x04,0xDB,
+0xE4,0x90,0x00,0x0C,0xF0,0xA3,0xF0,0x90,
+0x00,0x0D,0xE0,0x04,0xF0,0x70,0x06,0x90,
+0x00,0x0C,0xE0,0x04,0xF0,0x90,0x00,0x0C,
+0xE0,0xB4,0x0B,0xEB,0xA3,0xE0,0xB4,0xB8,
+0xE6,0x7D,0x66,0x7C,0x00,0x7F,0xC4,0x7E,
+0x13,0x12,0x04,0xDB,0x22,0xE4,0x90,0x00,
+0x00,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+0x7D,0x51,0xFC,0x7F,0x36,0x7E,0x13,0x12,
+0x04,0xDB,0xE4,0x90,0x00,0x08,0xF0,0xA3,
+0xF0,0x90,0x00,0x09,0xE0,0x04,0xF0,0x70,
+0x06,0x90,0x00,0x08,0xE0,0x04,0xF0,0x90,
+0x00,0x08,0xE0,0x70,0x04,0xA3,0xE0,0x64,
+0x64,0x70,0xE6,0xE4,0x90,0x00,0x08,0xF0,
+0xA3,0xF0,0xE4,0xFF,0xFE,0x0F,0xBF,0x00,
+0x01,0x0E,0xEF,0x64,0x32,0x4E,0x70,0xF5,
+0x90,0x00,0x09,0xE0,0x04,0xF0,0x70,0x06,
+0x90,0x00,0x08,0xE0,0x04,0xF0,0x90,0x00,
+0x08,0xE0,0xB4,0x75,0xDD,0xA3,0xE0,0xB4,
+0x30,0xD8,0x7F,0x59,0x7E,0x1B,0x12,0x04,
+0xF7,0xEF,0x4E,0x70,0xC6,0x7F,0x92,0x7E,
+0x1D,0x12,0x04,0xF7,0x90,0x00,0x06,0xEE,
+0xF0,0xA3,0xEF,0xF0,0x64,0x07,0x60,0x0A,
+0xEF,0x64,0x05,0x60,0x05,0xEF,0x64,0x04,
+0x70,0x19,0x90,0x00,0x01,0xE0,0x04,0xF0,
+0x70,0x06,0x90,0x00,0x00,0xE0,0x04,0xF0,
+0x90,0x00,0x00,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x12,0x01,0xA9,0x90,0x00,0x06,0xE0,0xFF,
+0x64,0x07,0x60,0x0D,0xEF,0x64,0x05,0x60,
+0x08,0xEF,0x64,0x04,0x60,0x03,0x02,0x03,
+0x8B,0x90,0x00,0x03,0xE0,0x04,0xF0,0x70,
+0x06,0x90,0x00,0x02,0xE0,0x04,0xF0,0x90,
+0x00,0x02,0xE0,0xFE,0xA3,0xE0,0xFF,0x12,
+0x00,0x03,0x02,0x03,0x8B,0x90,0x00,0x0E,
+0xEE,0xF0,0xA3,0xEF,0xF0,0xE4,0x90,0x00,
+0x16,0xF0,0xA3,0xF0,0xA3,0xF0,0xA3,0xF0,
+0xAE,0x02,0xEB,0x78,0x05,0xC3,0x33,0xCE,
+0x33,0xCE,0xD8,0xF9,0xFF,0xEE,0x4C,0xFE,
+0xEF,0x4D,0xFF,0x90,0x00,0x16,0xEE,0xF0,
+0xA3,0xEF,0xF0,0x90,0x00,0x0E,0xE0,0xFF,
+0xA3,0xE0,0x44,0xC0,0x90,0x00,0x18,0xCF,
+0xF0,0xA3,0xEF,0xF0,0x90,0x00,0x14,0xE0,
+0xFC,0xA3,0xE0,0xFD,0x7F,0x02,0x7E,0x66,
+0x12,0x04,0xDB,0x90,0x00,0x16,0xE0,0xFC,
+0xA3,0xE0,0xFD,0x7F,0x01,0x7E,0x66,0x12,
+0x04,0xDB,0x90,0x00,0x18,0xE0,0xFC,0xA3,
+0xE0,0xFD,0x7F,0x00,0x7E,0x66,0x12,0x04,
+0xDB,0x90,0x00,0x1A,0xE4,0xF0,0xA3,0x74,
+0x64,0xF0,0x90,0x00,0x1A,0xE0,0x70,0x02,
+0xA3,0xE0,0x60,0x2C,0x7F,0x00,0x7E,0x66,
+0x12,0x04,0xF7,0xEE,0x30,0xE0,0x18,0x90,
+0x00,0x1B,0xE0,0x24,0xFF,0xF0,0x90,0x00,
+0x1A,0xE0,0x34,0xFF,0xF0,0xE0,0x70,0x02,
+0xA3,0xE0,0x70,0xD6,0x7F,0xFF,0x22,0xE4,
+0x90,0x00,0x1A,0xF0,0xA3,0xF0,0x80,0xCA,
+0x7F,0x00,0x22,0xAB,0x07,0xAA,0x06,0x8A,
+0xA2,0x00,0x8B,0xA3,0x00,0x8C,0xA4,0x00,
+0x8D,0xA5,0x00,0x75,0xA0,0x03,0x00,0x00,
+0xAA,0xA1,0x00,0xBA,0x00,0xF9,0x22,0xAD,
+0x07,0xAC,0x06,0x8C,0xA2,0x00,0x8D,0xA3,
+0x00,0x75,0xA0,0x01,0x00,0xAE,0xA1,0x00,
+0xBE,0x00,0xF9,0x00,0xAE,0xA6,0x00,0xAF,
+0xA7,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xEC,0x64,
+0x80,0xC8,0x64,0x80,0x98,0x45,0xF0,0x22,
+0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,0x81,
+0x09,0x02,0x03,0x4D,};
+
+#define RTL8367C_MIB_RXB_ID		0	/* IfInOctets */
+#define RTL8367C_MIB_TXB_ID		20	/* IfOutOctets */
+
+
+static struct rtl8366_mib_counter rtl8367c_mib_counters[] = {
+	{ 0,  0, 4, "IfInOctets"				},
+	{ 0,  4, 2, "Dot3StatsFCSErrors"			},
+	{ 0,  6, 2, "Dot3StatsSymbolErrors"			},
+	{ 0,  8, 2, "Dot3InPauseFrames"				},
+	{ 0, 10, 2, "Dot3ControlInUnknownOpcodes"		},
+	{ 0, 12, 2, "EtherStatsFragments"			},
+	{ 0, 14, 2, "EtherStatsJabbers"				},
+	{ 0, 16, 2, "IfInUcastPkts"				},
+	{ 0, 18, 2, "EtherStatsDropEvents"			},
+	{ 0, 20, 4, "EtherStatsOctets"				},
+
+	{ 0, 24, 2, "EtherStatsUnderSizePkts"			},
+	{ 0, 26, 2, "EtherOversizeStats"			},
+	{ 0, 28, 2, "EtherStatsPkts64Octets"			},
+	{ 0, 30, 2, "EtherStatsPkts65to127Octets"		},
+	{ 0, 32, 2, "EtherStatsPkts128to255Octets"		},
+	{ 0, 34, 2, "EtherStatsPkts256to511Octets"		},
+	{ 0, 36, 2, "EtherStatsPkts512to1023Octets"		},
+	{ 0, 38, 2, "EtherStatsPkts1024to1518Octets"		},
+	{ 0, 40, 2, "EtherStatsMulticastPkts"			},
+	{ 0, 42, 2, "EtherStatsBroadcastPkts"			},
+
+	{ 0, 44, 4, "IfOutOctets"				},
+
+	{ 0, 48, 2, "Dot3StatsSingleCollisionFrames"		},
+	{ 0, 50, 2, "Dot3StatMultipleCollisionFrames"		},
+	{ 0, 52, 2, "Dot3sDeferredTransmissions"		},
+	{ 0, 54, 2, "Dot3StatsLateCollisions"			},
+	{ 0, 56, 2, "EtherStatsCollisions"			},
+	{ 0, 58, 2, "Dot3StatsExcessiveCollisions"		},
+	{ 0, 60, 2, "Dot3OutPauseFrames"			},
+	{ 0, 62, 2, "Dot1dBasePortDelayExceededDiscards"	},
+	{ 0, 64, 2, "Dot1dTpPortInDiscards"			},
+	{ 0, 66, 2, "IfOutUcastPkts"				},
+	{ 0, 68, 2, "IfOutMulticastPkts"			},
+	{ 0, 70, 2, "IfOutBroadcastPkts"			},
+	{ 0, 72, 2, "OutOampduPkts"				},
+	{ 0, 74, 2, "InOampduPkts"				},
+	{ 0, 76, 2, "PktgenPkts"				},
+};
+
+#define REG_RD(_smi, _reg, _val)					\
+	do {								\
+		err = rtl8366_smi_read_reg(_smi, _reg, _val);		\
+		if (err)						\
+			return err;					\
+	} while (0)
+
+#define REG_WR(_smi, _reg, _val)					\
+	do {								\
+		err = rtl8366_smi_write_reg(_smi, _reg, _val);		\
+		if (err)						\
+			return err;					\
+	} while (0)
+
+#define REG_RMW(_smi, _reg, _mask, _val)				\
+	do {								\
+		err = rtl8366_smi_rmwr(_smi, _reg, _mask, _val);	\
+		if (err)						\
+			return err;					\
+	} while (0)
+
+#define REG_RWBTS(_smi, _reg, _bits, _val)				\
+			do {								\
+				err = rtl8366_smi_rwbts(_smi, _reg, _bits, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+		
+#define REG_RWBT(_smi, _reg, _bit, _val)				\
+			do {								\
+				err = rtl8366_smi_rwbt(_smi, _reg, _bit, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+				
+#define REG_RDBT(_smi, _reg, _bit, _val)				\
+			do {								\
+				err = rtl8366_smi_rdbt(_smi, _reg, _bit, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+				
+#define REG_RDBTS(_smi, _reg, _bits, _val)				\
+			do {								\
+				err = rtl8366_smi_rdbts(_smi, _reg, _bits, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+
+static int rtl8367c_write_phy_reg(struct rtl8366_smi *smi,
+				 u32 phy_addr, u32 phy_reg, u32 val)
+{
+	int timeout;
+	u32 data;
+	int err;
+
+	dev_dbg(smi->parent, "phy_write: addr:%02x, reg:%02x, val:%04x\n",
+		phy_addr, phy_reg, val);
+
+	if (phy_addr > RTL8367C_PHY_ADDR_MAX)
+		return -EINVAL;
+
+	if (phy_reg > RTL8367C_PHY_REG_MAX)
+		return -EINVAL;
+
+	REG_RD(smi, RTL8367C_IA_STATUS_REG, &data);
+	if (data & RTL8367C_IA_STATUS_PHY_BUSY)
+		return -ETIMEDOUT;
+
+	/* preapre data */
+	REG_WR(smi, RTL8367C_IA_WRITE_DATA_REG, val);
+
+	/* prepare address */
+	REG_WR(smi, RTL8367C_IA_ADDRESS_REG,
+	       RTL8367C_INTERNAL_PHY_REG(phy_addr, phy_reg));
+
+	/* send write command */
+	REG_WR(smi, RTL8367C_IA_CTRL_REG,
+	       RTL8367C_IA_CTRL_CMD_MASK | RTL8367C_IA_CTRL_RW_WRITE);
+
+	timeout = 5;
+	do {
+		REG_RD(smi, RTL8367C_IA_STATUS_REG, &data);
+		if ((data & RTL8367C_IA_STATUS_PHY_BUSY) == 0)
+			break;
+
+		if (timeout--) {
+			dev_err(smi->parent, "phy write timed out\n");
+			return -ETIMEDOUT;
+		}
+
+		udelay(1);
+	} while (1);
+
+	return 0;
+}
+
+static int rtl8367c_read_phy_reg(struct rtl8366_smi *smi,
+				u32 phy_addr, u32 phy_reg, u32 *val)
+{
+	int timeout;
+	u32 data;
+	int err;
+
+	if (phy_addr > RTL8367C_PHY_ADDR_MAX)
+		return -EINVAL;
+
+	if (phy_reg > RTL8367C_PHY_REG_MAX)
+		return -EINVAL;
+
+	REG_RD(smi, RTL8367C_IA_STATUS_REG, &data);
+	if (data & RTL8367C_IA_STATUS_PHY_BUSY)
+		return -ETIMEDOUT;
+
+	/* prepare address */
+	REG_WR(smi, RTL8367C_IA_ADDRESS_REG,
+	       RTL8367C_INTERNAL_PHY_REG(phy_addr, phy_reg));
+
+	/* send read command */
+	REG_WR(smi, RTL8367C_IA_CTRL_REG,
+	       RTL8367C_IA_CTRL_CMD_MASK | RTL8367C_IA_CTRL_RW_READ);
+
+	timeout = 5;
+	do {
+		REG_RD(smi, RTL8367C_IA_STATUS_REG, &data);
+		if ((data & RTL8367C_IA_STATUS_PHY_BUSY) == 0)
+			break;
+
+		if (timeout--) {
+			dev_err(smi->parent, "phy read timed out\n");
+			return -ETIMEDOUT;
+		}
+
+		udelay(1);
+	} while (1);
+
+	/* read data */
+	REG_RD(smi, RTL8367C_IA_READ_DATA_REG, val);
+
+	dev_dbg(smi->parent, "phy_read: addr:%02x, reg:%02x, val:%04x\n",
+		phy_addr, phy_reg, *val);
+	return 0;
+}
+
+static int rtl8367c_mii_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct rtl8366_smi *smi = bus->priv;
+	u32 val = 0;
+	int err;
+
+	err = rtl8367c_read_phy_reg(smi, addr, reg, &val);
+	if (err)
+		return 0xffff;
+
+	return val;
+}
+
+static int rtl8367c_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct rtl8366_smi *smi = bus->priv;
+	u32 t;
+	int err;
+
+	err = rtl8367c_write_phy_reg(smi, addr, reg, val);
+	if (err)
+		return err;
+
+	/* flush write */
+	(void) rtl8367c_read_phy_reg(smi, addr, reg, &t);
+
+	return err;
+}
+
+
+int rtl8367c_getAsicPHYOCPReg(struct rtl8366_smi *smi, u32 phyNo, u32 ocpAddr, u32 *pRegData)
+{
+	int err;
+    u32 regAddr;
+    u32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+	 /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    REG_RWBTS(smi, RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix);
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    REG_RD(smi, regAddr, pRegData);
+
+    return 0;
+
+
+}
+
+int rtl8367c_setAsicPHYOCPReg(struct rtl8366_smi *smi, u32 phyNo, u32 ocpAddr, u32 ocpData )
+{
+    int err;
+    u32 regAddr;
+    u32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    REG_RWBTS(smi, RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix);
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    REG_WR(smi, regAddr, ocpData);
+
+    return 0;
+}
+
+int rtl8367c_setAsicPortIngressBandwidth(struct rtl8366_smi *smi, u32 port, u32 bandwidth, u32 preifg, u32 enableFC)
+{
+	int err;
+    u32 regData;
+    u32 regAddr;
+
+    regAddr = RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port);
+    regData = bandwidth & RTL8367C_QOS_GRANULARTY_LSB_MASK;
+    REG_WR(smi, regAddr, regData);    
+
+    regAddr += 1;
+    regData = (bandwidth & RTL8367C_QOS_GRANULARTY_MSB_MASK) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;
+    REG_RWBTS(smi, regAddr, RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK, regData);    
+
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    REG_RWBT(smi, regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET, preifg);
+ 
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    REG_RWBT(smi, regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET, enableFC);
+    
+
+    return 0;
+}
+
+int rtl8367c_setAsicPortEgressRate(struct rtl8366_smi *smi, u32 port, u32 rate)
+{
+    u32 regAddr, regData;
+	int err;
+
+    regAddr = RTL8367C_PORT_EGRESSBW_LSB_REG(port);
+    regData = RTL8367C_QOS_GRANULARTY_LSB_MASK & rate;
+
+    REG_WR(smi, regAddr, regData);
+
+    regAddr = RTL8367C_PORT_EGRESSBW_MSB_REG(port);
+    regData = (RTL8367C_QOS_GRANULARTY_MSB_MASK & rate) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;
+    REG_RWBTS(smi, regAddr, RTL8367C_PORT6_EGRESSBW_CTRL1_MASK, regData);
+
+    return 0;
+}
+
+int rtl8367c_setAsicPortEgressRateIfg(struct rtl8366_smi *smi, u32 ifg)
+{
+	int err;
+    REG_RWBT(smi, RTL8367C_REG_SCHEDULE_WFQ_CTRL, RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET, ifg);
+    return 0;
+}
+
+int rtl8367c_setAsicLutIpLookupMethod(struct rtl8366_smi *smi, u32 type)
+{
+	int err;
+	REG_RWBT(smi, RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET, type);
+    return 0;
+}
+
+int rtl8367c_setAsicRma(struct rtl8366_smi *smi, u32 index, rtl8367c_rma_t* pRmacfg)
+{  
+	int err;
+	u32 regData = 0;
+	
+    regData |= (pRmacfg->portiso_leaky & 0x0001);
+    regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
+    regData |= ((pRmacfg->keep_format & 0x0001) << 2);
+    regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
+    regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
+    regData |= ((pRmacfg->operation & 0x0003) << 7);
+
+    if( (index >= 0x4 && index <= 0x7) || (index >= 0x9 && index <= 0x0C) || (0x0F == index))
+        index = 0x04;
+    else if((index >= 0x13 && index <= 0x17) || (0x19 == index) || (index >= 0x1B && index <= 0x1f))
+        index = 0x13;
+    else if(index >= 0x22 && index <= 0x2F)
+        index = 0x22;
+
+    REG_RWBTS(smi, RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
+    REG_WR(smi, RTL8367C_REG_RMA_CTRL00+index, regData);
+
+    return 0;
+}
+
+static int rtl8367c_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
+				struct rtl8366_vlan_4k *vlan4k)
+{
+	u32 data[RTL8367C_TA_VLAN_DATA_SIZE];
+	int err;
+	int i;
+
+	memset(vlan4k, '\0', sizeof(struct rtl8366_vlan_4k));
+
+	if (vid >= RTL8367C_NUM_VIDS)
+		return -EINVAL;
+
+	/* write VID */
+	REG_WR(smi, RTL8367C_TA_ADDR_REG, vid);
+
+	/* write table access control word */
+	REG_WR(smi, RTL8367C_TA_CTRL_REG, RTL8367C_TA_CTRL_CVLAN_READ);
+
+	for (i = 0; i < ARRAY_SIZE(data); i++)
+		REG_RD(smi, RTL8367C_TA_DATA_REG(i), &data[i]);
+
+	vlan4k->vid = vid;
+	vlan4k->member = (data[0] >> RTL8367C_TA_VLAN_MEMBER_SHIFT) &
+			 RTL8367C_TA_VLAN_MEMBER_MASK;
+	vlan4k->fid = (data[1] >> RTL8367C_TA_VLAN_FID_SHIFT) &
+		      RTL8367C_TA_VLAN_FID_MASK;
+	vlan4k->untag = (data[2] >> RTL8367C_TA_VLAN_UNTAG1_SHIFT) &
+			RTL8367C_TA_VLAN_UNTAG1_MASK;
+	vlan4k->untag |= ((data[3] >> RTL8367C_TA_VLAN_UNTAG2_SHIFT) &
+			  RTL8367C_TA_VLAN_UNTAG2_MASK) << 2;
+
+	return 0;
+}
+
+static int rtl8367c_set_vlan_4k(struct rtl8366_smi *smi,
+				const struct rtl8366_vlan_4k *vlan4k)
+{
+	u32 data[RTL8367C_TA_VLAN_DATA_SIZE];
+	int err;
+	int i;
+
+	if (vlan4k->vid >= RTL8367C_NUM_VIDS ||
+	    vlan4k->member > RTL8367C_TA_VLAN_MEMBER_MASK ||
+	    vlan4k->untag > RTL8367C_UNTAG_MASK ||
+	    vlan4k->fid > RTL8367C_FIDMAX)
+		return -EINVAL;
+
+	data[0] = (vlan4k->member & RTL8367C_TA_VLAN_MEMBER_MASK) <<
+		  RTL8367C_TA_VLAN_MEMBER_SHIFT;
+	data[1] = (vlan4k->fid & RTL8367C_TA_VLAN_FID_MASK) <<
+		  RTL8367C_TA_VLAN_FID_SHIFT;
+	data[2] = (vlan4k->untag & RTL8367C_TA_VLAN_UNTAG1_MASK) <<
+		  RTL8367C_TA_VLAN_UNTAG1_SHIFT;
+	data[3] = ((vlan4k->untag >> 2) & RTL8367C_TA_VLAN_UNTAG2_MASK) <<
+		  RTL8367C_TA_VLAN_UNTAG2_SHIFT;
+
+	for (i = 0; i < ARRAY_SIZE(data); i++)
+		REG_WR(smi, RTL8367C_TA_DATA_REG(i), data[i]);
+
+	/* write VID */
+	REG_WR(smi, RTL8367C_TA_ADDR_REG,
+	       vlan4k->vid & RTL8367C_TA_VLAN_VID_MASK);
+
+	/* write table access control word */
+	REG_WR(smi, RTL8367C_TA_CTRL_REG, RTL8367C_TA_CTRL_CVLAN_WRITE);
+
+	return 0;
+}
+
+static int rtl8367c_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
+				struct rtl8366_vlan_mc *vlanmc)
+{
+
+    u32 data[RTL8367C_VLAN_MC_DATA_SIZE];
+	int err;
+	int i;
+
+	memset(vlanmc, '\0', sizeof(struct rtl8366_vlan_mc));
+
+	if (index >= RTL8367C_NUM_VLANS)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(data); i++)
+		REG_RD(smi, RTL8367C_VLAN_MC_BASE(index) + i, &data[i]);
+
+	vlanmc->member = (data[0] >> RTL8367C_VLAN_MC_MEMBER_SHIFT) &
+			 RTL8367C_VLAN_MC_MEMBER_MASK;
+	vlanmc->fid = (data[1] >> RTL8367C_VLAN_MC_FID_SHIFT) &
+		      RTL8367C_VLAN_MC_FID_MASK;
+	vlanmc->vid = (data[3] >> RTL8367C_VLAN_MC_EVID_SHIFT) &
+		      RTL8367C_VLAN_MC_EVID_MASK;
+
+	return 0;
+}
+
+static int rtl8367c_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
+				const struct rtl8366_vlan_mc *vlanmc)
+{
+
+	u32 data[RTL8367C_VLAN_MC_DATA_SIZE];
+	int err;
+	int i;
+	
+	if (index >= RTL8367C_NUM_VLANS ||
+	    vlanmc->vid >= RTL8367C_NUM_VIDS ||
+	    vlanmc->priority > RTL8367C_PRIORITYMAX ||
+	    vlanmc->member > RTL8367C_VLAN_MC_MEMBER_MASK ||
+	    vlanmc->untag > RTL8367C_UNTAG_MASK)// ||
+//	    vlanmc->fid > RTL8367C_FIDMAX)
+		return -EINVAL;
+
+	data[0] = (vlanmc->member & RTL8367C_VLAN_MC_MEMBER_MASK) <<
+		  RTL8367C_VLAN_MC_MEMBER_SHIFT;
+	data[1] = (vlanmc->fid & RTL8367C_VLAN_MC_FID_MASK) <<
+		  RTL8367C_VLAN_MC_FID_SHIFT;
+	data[2] = 0;
+	data[3] = (vlanmc->vid & RTL8367C_VLAN_MC_EVID_MASK) <<
+		   RTL8367C_VLAN_MC_EVID_SHIFT;
+
+	for (i = 0; i < ARRAY_SIZE(data); i++)
+		REG_WR(smi, RTL8367C_VLAN_MC_BASE(index) + i, data[i]);
+
+	return 0;
+}
+
+
+static int rtl8367c_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
+{
+	u32 data;
+	int err;
+
+	if (port >= RTL8367C_NUM_PORTS)
+		return -EINVAL;
+
+	REG_RD(smi, RTL8367C_VLAN_PVID_CTRL_REG(port), &data);
+
+	*val = (data >> RTL8367C_VLAN_PVID_CTRL_SHIFT(port)) &
+	       RTL8367C_VLAN_PVID_CTRL_MASK;
+
+	return 0;
+}
+
+static int rtl8367c_set_mc_index(struct rtl8366_smi *smi, int port, int index)
+{
+	if (port >= RTL8367C_NUM_PORTS || index >= RTL8367C_NUM_VLANS)
+		return -EINVAL;
+
+	return rtl8366_smi_rmwr(smi, RTL8367C_VLAN_PVID_CTRL_REG(port),
+				RTL8367C_VLAN_PVID_CTRL_MASK <<
+					RTL8367C_VLAN_PVID_CTRL_SHIFT(port),
+				(index & RTL8367C_VLAN_PVID_CTRL_MASK) <<
+					RTL8367C_VLAN_PVID_CTRL_SHIFT(port));
+}
+
+static int rtl8367c_get_mib_counter(struct rtl8366_smi *smi, int counter,
+				   int port, unsigned long long *val)
+{
+	int err;
+    u32 regAddr;
+    u32 regData;
+    u32 mibAddr;
+    u32 mibOff=0;
+
+    /* address offset to MIBs counter */
+    const u16 mibLength[RTL8367C_MIBS_NUMBER]= {
+        4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+        4,2,2,2,2,2,2,2,2,
+        4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2};
+
+    u16 i;
+    u64 mibCounter;
+
+
+    if(dot1dTpLearnedEntryDiscards == counter)
+    {
+        mibAddr = RTL8367C_MIB_LEARNENTRYDISCARD_OFFSET;
+    }
+    else
+    {
+        i = 0;
+        mibOff = RTL8367C_MIB_PORT_OFFSET * port;
+
+        if(port > 7)
+            mibOff = mibOff + 68;
+
+        while(i < counter)
+        {
+            mibOff += mibLength[i];
+            i++;
+        }
+
+        mibAddr = mibOff;
+    }
+
+    /* Read MIB addr before writing */
+    REG_RD(smi, RTL8367C_REG_MIB_ADDRESS, &regData);
+
+    if (regData == (mibAddr >> 2))
+    {
+        /* Write MIB addr to an alternate value */
+        REG_WR(smi, RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2) + 1);
+        while(1)
+        {
+            REG_RD(smi, RTL8367C_REG_MIB_ADDRESS, &regData);
+
+            if(regData == ((mibAddr >> 2) + 1))
+            {
+                break;
+            }
+
+            REG_WR(smi, RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2) + 1);
+        }
+
+        /* polling busy flag */
+        i = 100;
+        while(i > 0)
+        {
+            /*read MIB control register*/
+            REG_RD(smi, RTL8367C_MIB_CTRL_REG,&regData);
+
+            if((regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK) == 0)
+            {
+                break;
+            }
+
+            i--;
+        }
+
+        if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
+            return -1;
+
+        if(regData & RTL8367C_RESET_FLAG_MASK)
+            return -1;
+    }
+
+    /*writing access counter address first*/
+    /*This address is SRAM address, and SRAM address = MIB register address >> 2*/
+    /*then ASIC will prepare 64bits counter wait for being retrived*/
+    /*Write Mib related address to access control register*/
+    REG_WR(smi, RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
+
+    /* polling MIB Addr register */
+    while(1)
+    {
+        REG_RD(smi, RTL8367C_REG_MIB_ADDRESS, &regData);
+        if(regData == (mibAddr >> 2))
+        {
+            break;
+        }
+
+        REG_WR(smi, RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
+    }
+
+    /* polling busy flag */
+    i = 100;
+    while(i > 0)
+    {
+        /*read MIB control register*/
+        REG_RD(smi, RTL8367C_MIB_CTRL_REG,&regData);
+
+        if((regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK) == 0)
+        {
+            break;
+        }
+
+        i--;
+    }
+
+    if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
+        return -1;
+
+    if(regData & RTL8367C_RESET_FLAG_MASK)
+        return -1;
+
+    mibCounter = 0;
+    i = mibLength[counter];
+    if(4 == i)
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 3;
+    else
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + ((mibOff + 1) % 4);
+
+    while(i)
+    {
+        REG_RD(smi, regAddr, &regData);
+
+        mibCounter = (mibCounter << 16) | (regData & 0xFFFF);
+
+        regAddr --;
+        i --;
+
+    }
+
+    *val = mibCounter;
+
+    return 0;
+}
+
+static int rtl8367c_is_vlan_valid(struct rtl8366_smi *smi, unsigned vlan)
+{
+	unsigned max = RTL8367C_NUM_VLANS;
+
+	if (smi->vlan4k_enabled)
+		max = RTL8367C_NUM_VIDS - 1;
+
+	if (vlan == 0 || vlan >= max)
+		return 0;
+	return 1;
+}
+
+
+int rtl8367c_setAsicVlanPortBasedVID(struct rtl8366_smi *smi, u32 port, u32 index, u32 pri)
+{
+    u32 regAddr, bit_mask;
+    int err;
+
+    regAddr = RTL8367C_VLAN_PVID_CTRL_REG(port);
+    bit_mask = RTL8367C_PORT_VIDX_MASK(port);
+    REG_RWBTS(smi, regAddr, bit_mask, index);
+    
+
+    regAddr = RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port);
+    bit_mask = RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port);
+    REG_RWBTS(smi, regAddr, bit_mask, pri);
+   
+    return 0;
+} 
+
+static void _rtl8367c_VlanMCStUser2Smi(struct rtl8366_vlan_mc *pVlanCg, u16 *pSmiVlanCfg)
+{
+    pSmiVlanCfg[0] |= pVlanCg->member & 0x07FF;
+
+    pSmiVlanCfg[1] |= pVlanCg->fid & 0x000F;
+	
+	pSmiVlanCfg[2] = 0;
+
+
+    pSmiVlanCfg[3] |= pVlanCg->vid & 0x1FFF;
+}
+
+static void _rtl8367c_Vlan4kStUser2Smi(struct rtl8366_vlan_4k *pUserVlan4kEntry, u16 *pSmiVlan4kEntry)
+{
+    pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->member & 0x00FF);
+    pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->untag & 0x00FF) << 8;
+
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->fid & 0x000F);
+
+    pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->member & 0x0700) >> 8);
+    pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->untag & 0x0700) >> 8) << 3;
+}
+
+
+int rtl8367c_setAsicVlanMemberConfig(struct rtl8366_smi *smi, u32 index, struct rtl8366_vlan_mc *pVlanCg)
+{
+    int err;
+    u32 regAddr;
+    u32 regData;
+    u16 *tableAddr;
+    u32 page_idx;
+    u16 smi_vlancfg[RTL8367C_VLAN_MBRCFG_LEN];
+
+    memset(smi_vlancfg, 0x00, sizeof(u16) * RTL8367C_VLAN_MBRCFG_LEN);
+    _rtl8367c_VlanMCStUser2Smi(pVlanCg, smi_vlancfg);
+    tableAddr = smi_vlancfg;
+
+    for(page_idx = 0; page_idx < 4; page_idx++)  /* 4 pages per VLAN Member Config */
+    {
+        regAddr = RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE + (index * 4) + page_idx;
+        regData = *tableAddr;
+
+        REG_WR(smi, regAddr, regData);
+     
+
+        tableAddr++;
+    }
+
+    return 0;
+}
+ 
+ int rtl8367c_setAsicVlan4kEntry(struct rtl8366_smi *smi, struct rtl8366_vlan_4k *pVlan4kEntry )
+{
+    u16              vlan_4k_entry[RTL8367C_VLAN_4KTABLE_LEN];
+    u32                  page_idx;
+    u16                  *tableAddr;
+    int                   err;
+    u32                  regData;
+	
+ 
+    memset(vlan_4k_entry, 0x00, sizeof(u16) * RTL8367C_VLAN_4KTABLE_LEN);
+    _rtl8367c_Vlan4kStUser2Smi(pVlan4kEntry, vlan_4k_entry);
+
+    /* Prepare Data */
+    tableAddr = vlan_4k_entry;
+    for(page_idx = 0; page_idx < RTL8367C_VLAN_4KTABLE_LEN; page_idx++)
+    {
+        regData = *tableAddr;
+        REG_WR(smi, RTL8367C_TABLE_ACCESS_WRDATA_BASE + page_idx, regData);
+        tableAddr++;
+    }
+
+    /* Write Address (VLAN_ID) */
+    regData = pVlan4kEntry->vid;
+    REG_WR(smi, RTL8367C_TABLE_ACCESS_ADDR_REG, regData);
+	
+    /* Write Command */
+    REG_RWBTS(smi, RTL8367C_TABLE_ACCESS_CTRL_REG, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK,RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE,TB_TARGET_CVLAN));
+    
+
+    return 0;
+}
+ 
+ 
+
+static int rtl8367c_enable_vlan(struct rtl8366_smi *smi, int enable)
+{
+	int err, i;
+	int retVal;
+ 	struct rtl8366_vlan_4k vlan4k;
+ 	struct rtl8366_vlan_mc  vlanMC;
+	
+	 for (i = 0; i <= 31; i++)
+    {
+        vlanMC.vid = 0;
+        vlanMC.member = 0;
+        vlanMC.fid = 0;
+        if ((retVal = rtl8367c_setAsicVlanMemberConfig(smi, i, &vlanMC)) != 0)
+            return retVal;
+    }
+	
+ 	memset(&vlan4k, 0, sizeof(vlan4k));
+    vlan4k.vid = 1;
+    vlan4k.member = RTK_PHY_PORTMASK_ALL;
+    vlan4k.untag = RTK_PHY_PORTMASK_ALL;
+    vlan4k.fid = 0;
+    if ((retVal = rtl8367c_setAsicVlan4kEntry(smi, &vlan4k)) != 0)
+        return retVal;
+		
+	memset(&vlanMC, 0, sizeof(vlanMC));
+    vlanMC.vid = 1;
+    vlanMC.member = RTK_PHY_PORTMASK_ALL;
+    vlanMC.fid = 0;
+    if ((retVal = rtl8367c_setAsicVlanMemberConfig(smi, 0, &vlanMC)) != 0)
+            return retVal;
+	for (i = 0; i <= 31; i++)
+		rtl8367c_setAsicVlanPortBasedVID(smi, i, 0, 0);		
+	
+	
+	REG_RWBT(smi, RTL8367C_REG_VLAN_CTRL, RTL8367C_VLAN_CTRL_OFFSET, (enable) ? RTL8367C_VLAN_CTRL_ENABLE : 0);
+	printk("===========rtl8367c_enable_vlan====err = %d\n", err);
+	return 0;
+}
+
+static int rtl8367c_enable_vlan4k(struct rtl8366_smi *smi, int enable)
+{
+	return 0;
+}
+
+
+static int rtl8367c_init_regs(struct rtl8366_smi *smi)
+{
+	u32 data, regValue;
+	u32 port;
+	rtl8367c_rma_t rmaCfg;
+	int err;
+	
+	REG_WR(smi, RTL8367C_REG_MAGIC_ID_REG, RTL8367C_REG_MAGIC_ID_VAL);
+
+	REG_RD(smi, RTL8367C_CHIP_VER_REG, &regValue);
+	
+	
+	REG_WR(smi, RTL8367C_REG_MAGIC_ID_REG, 0X0000);
+
+	for(port = 0; port < 5; port++)
+    {
+    	REG_RWBT(smi, RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_100M_OFFSET, 1);
+		REG_RWBT(smi, RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_OFFSET, 1);
+		REG_RWBT(smi, RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_TX_OFFSET, 1);
+		REG_RWBT(smi, RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_RX_OFFSET, 1);
+
+		rtl8367c_getAsicPHYOCPReg(smi, port, 0xA428, &data);
+		
+		data &= ~(0x0200);
+		rtl8367c_setAsicPHYOCPReg(smi, port, 0xA428, data);
+		
+		if((regValue & 0x00F0) == 0x00A0)
+		{
+			rtl8367c_getAsicPHYOCPReg(smi, port, 0xA5D0, &data);		
+			data |= 0x0006;
+			rtl8367c_setAsicPHYOCPReg(smi, port, 0xA5D0, data);
+		}
+    }
+
+	REG_WR(smi, 0x1303, 0x06D6);
+    REG_WR(smi, 0x1304, 0x0700);
+    REG_WR(smi, 0x13E2, 0x003F);
+    REG_WR(smi, 0x13F9, 0x0090);
+    REG_WR(smi, 0x121e, 0x03CA);
+    REG_WR(smi, 0x1233, 0x0352);
+    REG_WR(smi, 0x1237, 0x00a0);
+    REG_WR(smi, 0x123a, 0x0030);
+    REG_WR(smi, 0x1239, 0x0084);
+    REG_WR(smi, 0x0301, 0x1000);
+    REG_WR(smi, 0x1349, 0x001F);
+    REG_RWBT(smi, 0x18e0, 0, 0);
+    REG_RWBT(smi, 0x122b, 14, 1);
+    REG_RWBTS(smi, 0x1305, 0xC000, 3);
+    REG_RWBT(smi, 0x13f0, 0, 0);
+    REG_WR(smi, 0x1722, 0x1158);
+	
+       
+	 /* Set Old max packet length to 16K */
+    REG_RWBTS(smi, RTL8367C_REG_MAX_LENGTH_LIMINT_IPG, RTL8367C_MAX_LENTH_CTRL_MASK, 3);
+    REG_RWBTS(smi, RTL8367C_REG_MAX_LEN_RX_TX, RTL8367C_MAX_LEN_RX_TX_MASK, 3);
+    /* ACL Mode */
+    REG_RWBTS(smi, RTL8367C_REG_ACL_ACCESS_MODE, RTL8367C_ACL_ACCESS_MODE_MASK, 1);
+	
+
+    /* Max rate */
+    rtl8367c_setAsicPortIngressBandwidth(smi, 6, RTL8367C_QOS_RATE_INPUT_MAX_HSG>>3, DISABLED, ENABLED);
+
+    rtl8367c_setAsicPortEgressRate(smi, 6, RTL8367C_QOS_RATE_INPUT_MAX_HSG>>3);
+       
+    rtl8367c_setAsicPortEgressRateIfg(smi, ENABLED);
+
+    REG_WR(smi, 0x03fa, 0x0007);
+    /* Change unknown DA to per port setting */
+    REG_RWBTS(smi, RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_UNICAST_DA_BEHAVE_MASK, 3);
+
+    /* LUT lookup OP = 1 */
+    rtl8367c_setAsicLutIpLookupMethod(smi, 1);
+    
+
+	/* Set RMA */
+    rmaCfg.portiso_leaky = 0;
+    rmaCfg.vlan_leaky = 0;
+    rmaCfg.keep_format = 0;
+    rmaCfg.trap_priority = 0;
+    rmaCfg.discard_storm_filter = 0;
+    rmaCfg.operation = 0;
+    rtl8367c_setAsicRma(smi, 2, &rmaCfg);
+    
+
+    /* Enable TX Mirror isolation leaky */
+	REG_RWBT(smi, RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET, ENABLED);
+   
+	/* INT EN */
+    REG_RWBT(smi, RTL8367C_REG_IO_MISC_FUNC, RTL8367C_INT_EN_OFFSET, 1);
+
+	return 0;
+}
+
+static int rtl8367c_extif_set_rgmii_delay(struct rtl8366_smi *smi, int id,
+					 unsigned txdelay, unsigned rxdelay)
+{
+	u32 mask;
+	u32 val;
+	int err;
+
+	mask = (RTL8367C_EXT_RGMXF_RXDELAY_MASK |
+		(RTL8367C_EXT_RGMXF_TXDELAY_MASK <<
+			RTL8367C_EXT_RGMXF_TXDELAY_SHIFT));
+
+	val = rxdelay;
+	val |= txdelay << RTL8367C_EXT_RGMXF_TXDELAY_SHIFT;
+
+	REG_RMW(smi, RTL8367C_EXT_RGMXF_REG(id), mask, val);
+
+	return 0;
+}
+
+static int rtl8367c_reset_chip(struct rtl8366_smi *smi)
+{
+	int timeout = 10;
+	int err;
+	u32 data;
+
+	REG_WR(smi, RTL8367C_CHIP_RESET_REG, RTL8367C_CHIP_RESET_HW);
+	msleep(RTL8367C_RESET_DELAY);
+
+	do {
+		REG_RD(smi, RTL8367C_CHIP_RESET_REG, &data);
+		if (!(data & RTL8367C_CHIP_RESET_HW))
+			break;
+
+		msleep(1);
+	} while (--timeout);
+
+	if (!timeout) {
+		dev_err(smi->parent, "chip reset timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+int rtl8367c_setAsicPortForceLinkExt(struct rtl8366_smi *smi, u32 id, struct rtl8367c_port_ability *pPortAbility)
+{
+    u32  regValue, type;
+    u32 reg_data = 0;
+	int err;
+
+    reg_data |= pPortAbility->force_mode << 12;
+    reg_data |= pPortAbility->mstfault << 9;
+    reg_data |= pPortAbility->mstmode << 8;
+    reg_data |= pPortAbility->nway << 7;
+    reg_data |= pPortAbility->txpause << 6;
+    reg_data |= pPortAbility->rxpause << 5;
+    reg_data |= pPortAbility->link << 4;
+    reg_data |= pPortAbility->duplex << 2;
+    reg_data |= pPortAbility->speed;
+
+    REG_WR(smi, 0x13C2, 0x0249);   
+    /*get chip ID */
+    REG_RD(smi, 0x1300, &regValue);
+    REG_WR(smi, 0x13C2, 0x0000);
+
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return -1;
+    }
+
+    if (1 == type)
+    {
+        if(1 == id)
+        {
+            REG_RD(smi, RTL8367C_REG_REG_TO_ECO4, &regValue);
+            if((regValue & (0x0001 << 5)) && (regValue & (0x0001 << 7)))
+                return 0;
+
+            REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex);
+            REG_RWBTS(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed);
+            REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link);
+            REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause);
+            REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause);
+
+        }
+
+        if(0 == id || 1 == id)
+            REG_WR(smi, RTL8367C_REG_DIGITAL_INTERFACE0_FORCE + id, reg_data);
+        else
+            REG_WR(smi, RTL8367C_REG_DIGITAL_INTERFACE2_FORCE, reg_data);
+    }
+    else
+    	dev_err(smi->parent, "invalid type for external interface %d\n", id);
+
+
+    return 0;
+}
+
+int rtl8367c_setAsicPortExtMode(struct rtl8366_smi *smi, u32 id, u32 mode)
+{
+    u32 i, type, option, regValue;
+    u32 idx;
+	int err;
+    u32 redData[][2] =   { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x21A2, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    u32 redDataSB[][2] = { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x2420, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    u32 redData1[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData5[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData6[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData8[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData9[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redDataHB[][2] = { {0x82F0, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x7960, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+
+
+    REG_WR(smi, 0x13C2, 0x0249);
+    REG_RD(smi, 0x1300, &regValue);
+    REG_WR(smi, 0x13C2, 0x0000);
+    type = 0;
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return -1;
+    }
+
+
+    if (1==type)
+    {
+        if((mode == RTL8367C_EXT_1000X_100FX) || (mode == RTL8367C_EXT_1000X) || (mode == RTL8367C_EXT_100FX))
+        {
+            REG_RWBT(smi, RTL8367C_REG_REG_TO_ECO4, 5, 1);
+            REG_RWBT(smi, RTL8367C_REG_REG_TO_ECO4, 7, 1);             
+            REG_RWBT(smi, RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367C_REG_MISCELLANEOUS_CONFIGURE0, RTL8367C_DW8051_EN_OFFSET, 1);       
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 1);
+			REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0);
+            if(mode == RTL8367C_EXT_1000X_100FX)
+            {
+                for(idx = 0; idx < FIBER2_AUTO_INIT_SIZE; idx++)
+                {
+                    REG_WR(smi, 0xE000 + idx, (u32)Fiber2_Auto[idx]);                      
+                }
+            }
+            if(mode == RTL8367C_EXT_1000X)
+            {
+                for(idx = 0; idx < FIBER2_1G_INIT_SIZE; idx++)
+                {
+                    REG_WR(smi, 0xE000 + idx, (u32)Fiber2_1G[idx]);                      
+                }
+            }
+            if(mode == RTL8367C_EXT_100FX)
+            {
+                for(idx = 0; idx < FIBER2_100M_INIT_SIZE; idx++)
+                {
+                    REG_WR(smi, 0xE000 + idx, (u32)Fiber2_100M[idx]);                      
+                }
+            }
+
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0);              
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 0);               
+            REG_RWBT(smi, RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 0);               
+        }
+
+        if(mode == RTL8367C_EXT_GMII)
+        {
+            REG_RWBT(smi, RTL8367C_REG_EXT0_RGMXF, RTL8367C_EXT0_RGTX_INV_OFFSET, 1);               
+            REG_RWBT(smi, RTL8367C_REG_EXT1_RGMXF, RTL8367C_EXT1_RGTX_INV_OFFSET, 1);               
+            REG_RWBTS(smi, RTL8367C_REG_EXT_TXC_DLY, RTL8367C_EXT1_GMII_TX_DELAY_MASK, 5);               
+            REG_RWBTS(smi, RTL8367C_REG_EXT_TXC_DLY, RTL8367C_EXT0_GMII_TX_DELAY_MASK, 6);               
+        }
+
+        /* Serdes reset */
+        if( (mode == RTL8367C_EXT_TMII_MAC) || (mode == RTL8367C_EXT_TMII_PHY) )
+        {
+            REG_RWBT(smi, RTL8367C_REG_BYPASS_LINE_RATE, id, 1);              
+        }
+        else
+        {
+			REG_RWBT(smi, RTL8367C_REG_BYPASS_LINE_RATE, id, 0);               
+        }
+        if( (mode == RTL8367C_EXT_SGMII) || (mode == RTL8367C_EXT_HSGMII) )
+        {
+            REG_WR(smi, 0x13C0, 0x0249);
+            REG_RD(smi, 0x13C1, &option);              
+            REG_WR(smi, 0x13C0, 0x0000);               
+        }
+        if(mode == RTL8367C_EXT_SGMII)
+        {
+            if(option == 0)
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData[i][0]);                      
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData[i][1]);                       
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                      
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redDataSB[i][0]);                      
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redDataSB[i][1]);                      
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                       
+                }
+            }
+        }
+        if(mode == RTL8367C_EXT_HSGMII)
+        {
+            if(option == 0)
+            {
+                REG_WR(smi, 0x13c2, 0x0249);                  
+                REG_RD(smi, 0x1301, &regValue);                  
+                REG_WR(smi, 0x13c2, 0x0000);                  
+                if ( ((regValue & 0x00F0) >> 4) == 0x0001)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData1[i][0]);                          
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData1[i][1]);                          
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0005)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+						REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData5[i][0]);								
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData5[i][1]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0006)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+						REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData6[i][0]);
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData6[i][1]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0008)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData8[i][0]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData8[i][1]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0009)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redData9[i][0]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redData9[i][1]);                           
+                        REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);                          
+                    }
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 8; i++)
+                {
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, redDataHB[i][0]);                       
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, redDataHB[i][1]);                       
+                    REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);
+                       
+                }
+            }
+        }
+
+        /* Only one ext port should care SGMII setting */
+        if(id == 1)
+        {
+            if(mode == RTL8367C_EXT_SGMII)
+            {
+                REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 1);                   
+                REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 0);                   
+            }
+            else if(mode == RTL8367C_EXT_HSGMII)
+            {
+                REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 0);                   
+                REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 1);                   
+            }
+            else
+            {
+                if((mode != RTL8367C_EXT_1000X_100FX) && (mode != RTL8367C_EXT_1000X) && (mode != RTL8367C_EXT_100FX))
+                {
+                    REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 0);                       
+                    REG_RWBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 0);                       
+                }
+            }
+        }
+
+        if(0 == id || 1 == id)
+        {
+            REG_RWBTS(smi, RTL8367C_REG_DIGITAL_INTERFACE_SELECT, RTL8367C_SELECT_GMII_0_MASK << (id * RTL8367C_SELECT_GMII_1_OFFSET), mode);               
+        }
+        else
+        {
+            REG_RWBTS(smi, RTL8367C_REG_DIGITAL_INTERFACE_SELECT_1, RTL8367C_SELECT_GMII_2_MASK, mode);               
+        }
+
+        /* Serdes not reset */
+        if( (mode == RTL8367C_EXT_SGMII) || (mode == RTL8367C_EXT_HSGMII) )
+        {
+            REG_WR(smi, RTL8367C_REG_SDS_INDACS_DATA, 0x7106);               
+            REG_WR(smi, RTL8367C_REG_SDS_INDACS_ADR, 0x0003);              
+            REG_WR(smi, RTL8367C_REG_SDS_INDACS_CMD, 0x00C0);               
+        }
+
+        if( (mode == RTL8367C_EXT_SGMII) || (mode == RTL8367C_EXT_HSGMII) )
+        {
+            REG_RWBT(smi, RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367C_REG_MISCELLANEOUS_CONFIGURE0, RTL8367C_DW8051_EN_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 1);               
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0);              
+            for(idx = 0; idx < SGMII_INIT_SIZE; idx++)
+            {
+                REG_WR(smi, 0xE000 + idx, (u32)Sgmii_Init[idx]);                  
+            }
+
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0);               
+            REG_RWBT(smi, RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 0);              
+            REG_RWBT(smi, RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 0);              
+        }
+    }
+    else
+		dev_err(smi->parent, "invalid type for external interface %d\n", id);
+    return 0;
+}
+
+int rtl8367c_getAsicPortForceLinkExt(struct rtl8366_smi *smi, u32 id, struct rtl8367c_port_ability *pPortAbility)
+{
+    u32  reg_data, regValue, type;
+    u32  sgmiiSel;
+    u32  hsgmiiSel;
+	int err;
+
+    REG_WR(smi, 0x13C2, 0x0249);       
+    REG_RD(smi, 0x1300, &regValue);      
+    REG_WR(smi, 0x13C2, 0x0000);      
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return -1;
+    }
+    if (1 == type)
+    {
+        if(1 == id)
+        {
+            REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, &sgmiiSel);               
+            REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, &hsgmiiSel);               
+            if( (sgmiiSel == 1) || (hsgmiiSel == 1) )
+            {
+                memset(pPortAbility, 0x00, sizeof(struct rtl8367c_port_ability));
+                pPortAbility->force_mode = 1;
+                REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, &reg_data);                   
+                pPortAbility->duplex = reg_data;
+                REG_RDBTS(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, &reg_data);                   
+                pPortAbility->speed = reg_data;
+                REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, &reg_data);                   
+                pPortAbility->link = reg_data;
+                REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, &reg_data);                  
+                pPortAbility->txpause = reg_data;
+                REG_RDBT(smi, RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, &reg_data);                   
+                pPortAbility->rxpause = reg_data;
+                return 0;
+            }
+        }
+
+        if(0 == id || 1 == id)
+            REG_RD(smi, RTL8367C_REG_DIGITAL_INTERFACE0_FORCE+id, &reg_data);
+        else
+            REG_RD(smi, RTL8367C_REG_DIGITAL_INTERFACE2_FORCE, &reg_data);
+  
+        pPortAbility->force_mode = (reg_data >> 12) & 0x0001;
+        pPortAbility->mstfault  = (reg_data >> 9) & 0x0001;
+        pPortAbility->mstmode   = (reg_data >> 8) & 0x0001;
+        pPortAbility->nway      = (reg_data >> 7) & 0x0001;
+        pPortAbility->txpause   = (reg_data >> 6) & 0x0001;
+        pPortAbility->rxpause   = (reg_data >> 5) & 0x0001;
+        pPortAbility->link      = (reg_data >> 4) & 0x0001;
+        pPortAbility->duplex    = (reg_data >> 2) & 0x0001;
+        pPortAbility->speed     = reg_data & 0x0003;
+    }
+    else
+		dev_err(smi->parent, "invalid type for external interface %d\n", id);
+    
+    return 0;
+}
+
+
+static int rtl8367c_extif_set_force(struct rtl8366_smi *smi, int id, int mode, 
+				   struct rtl8367c_port_ability *pa)
+{
+	int retVal;
+    struct rtl8367c_port_ability ability;
+    u32 ext_id;
+
+    ext_id = 1;
+
+    if(mode == RTL8367C_EXT_DISABLE)
+    {
+        memset(&ability, 0x00, sizeof(struct rtl8367c_port_ability));
+        if ((retVal = rtl8367c_setAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicPortExtMode(smi, ext_id, mode)) != 0)
+            return retVal;
+    }
+	
+    else
+    {
+        if ((retVal = rtl8367c_setAsicPortExtMode(smi, ext_id, mode)) != 0)
+            return retVal;
+
+        if ((retVal = rtl8367c_getAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+
+        ability.force_mode = pa->force_mode;
+        ability.speed     = pa->speed;
+        ability.duplex    = pa->duplex;
+        ability.link      = pa->link;
+        ability.nway      = pa->nway;
+        ability.txpause   = pa->txpause;
+        ability.rxpause   = pa->rxpause;
+
+        if ((retVal = rtl8367c_setAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+    }
+
+    return 0;
+}
+
+
+static int rtl8367c_extif_init(struct rtl8366_smi *smi, int id,
+			      struct rtl8367c_extif_config *cfg)
+{
+	enum rtl8367c_extif_mode mode;
+	int err;
+
+	mode = (cfg) ? cfg->mode : RTL8367C_EXT_DISABLE;
+
+	if (mode != RTL8367C_EXT_DISABLE) {
+		err = rtl8367c_extif_set_force(smi, id, mode, &cfg->ability);
+		if (err)
+			return err;
+
+		err = rtl8367c_extif_set_rgmii_delay(smi, id, cfg->txdelay,
+						     cfg->rxdelay);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+
+static int rtl8367c_extif_init_of(struct rtl8366_smi *smi, int id,
+				 const char *name)
+{
+	struct rtl8367c_extif_config *cfg;
+	const __be32 *prop;
+	int size;
+	int err;
+
+	prop = of_get_property(smi->parent->of_node, name, &size);
+	if (!prop)
+		return rtl8367c_extif_init(smi, id, NULL);
+
+	if (size != (10 * sizeof(*prop))) {
+		dev_err(smi->parent, "%s property is invalid\n", name);
+		return -EINVAL;
+	}
+
+	cfg = kzalloc(sizeof(struct rtl8367c_extif_config), GFP_KERNEL);
+	if (!cfg)
+		return -ENOMEM;
+
+	cfg->txdelay = be32_to_cpup(prop++);
+	cfg->rxdelay = be32_to_cpup(prop++);
+	cfg->mode = be32_to_cpup(prop++);
+	cfg->ability.force_mode = be32_to_cpup(prop++);
+	cfg->ability.nway = be32_to_cpup(prop++);
+	cfg->ability.txpause = be32_to_cpup(prop++);
+	cfg->ability.rxpause = be32_to_cpup(prop++);
+	cfg->ability.link = be32_to_cpup(prop++);
+	cfg->ability.duplex = be32_to_cpup(prop++);
+	cfg->ability.speed = be32_to_cpup(prop++);	
+	printk("=======cfg->ability.speed = %d, cfg->ability.force_mode = %d, cfg->mode = %d=======\n", cfg->ability.speed, cfg->ability.force_mode, cfg->mode);
+
+	err = rtl8367c_extif_init(smi, id, cfg);
+	kfree(cfg);
+
+	return err;
+}
+
+
+static int rtl8367c_setup(struct rtl8366_smi *smi)
+{
+	struct rtl8367c_platform_data *pdata;
+	int err;
+
+	pdata = smi->parent->platform_data;
+
+	err = rtl8367c_init_regs(smi);
+	if (err)
+		return err;
+
+	/* initialize external interfaces */
+	if (smi->parent->of_node) {
+		err = rtl8367c_extif_init_of(smi, 0, "realtek,extif0");
+		if (err)
+			return err;
+
+		err = rtl8367c_extif_init_of(smi, 1, "realtek,extif1");
+		if (err)
+			return err;
+	} else {
+		err = rtl8367c_extif_init(smi, 0, pdata->extif0_cfg);
+		if (err)
+			return err;
+
+		err = rtl8367c_extif_init(smi, 1, pdata->extif1_cfg);
+		if (err)
+			return err;
+	}
+
+	/* set maximum packet length to 1536 bytes */
+//	REG_RMW(smi, RTL8367_SWC0_REG, RTL8367_SWC0_MAX_LENGTH_MASK,
+//		RTL8367_SWC0_MAX_LENGTH_1536);
+
+
+	return 0;
+}
+
+
+
+static int rtl8367c_detect(struct rtl8366_smi *smi)
+{
+	u32 rtl_no = 0;
+	u32 rtl_ver = 0;
+	char *chip_name;
+	int ret;
+	int err;
+
+	REG_WR(smi,0x13C2,0x0249);
+	ret = rtl8366_smi_read_reg(smi, RTL8367C_REG_CHIP_NUMBER, &rtl_no);
+	if (ret) {
+		dev_err(smi->parent, "unable to read chip number\n");
+		return ret;
+	}
+
+	switch (rtl_no) {
+		case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            chip_name = "8367C";
+			break;
+        case 0x0652:
+        case 0x6368:
+       		chip_name = "8370B";
+			break;
+        case 0x0801:
+        case 0x6511:
+            if( (rtl_no & 0x00F0) == 0x0080)
+            {
+                chip_name = "8363SC_VB";
+				break;
+            }
+            else
+            {
+            	chip_name = "8364B";
+				break;
+            }
+        default:
+            dev_err(smi->parent, "unknown chip number (%04x)\n", rtl_no);
+			return -ENODEV;
+	}
+
+	ret = rtl8366_smi_read_reg(smi, RTL8367C_CHIP_VER_REG, &rtl_ver);
+	if (ret) {
+		dev_err(smi->parent, "unable to read chip version\n");
+		return ret;
+	}
+
+	dev_info(smi->parent, "RTL%s ver. %u chip found\n",
+		 chip_name, rtl_ver & RTL8367C_REG_VER_MASK);
+
+	return 0;
+}
+
+
+int rtl8367c_getAsicPHYReg(struct rtl8366_smi *smi, u32 phyNo, u32 phyAddr, u32 *pRegData )
+{
+    u32 ocp_addr;
+
+    ocp_addr = 0xa400 + phyAddr*2;
+
+    return rtl8367c_getAsicPHYOCPReg(smi, phyNo, ocp_addr, pRegData);
+}
+
+
+
+int dal_rtl8367c_port_phyReg_get(struct rtl8366_smi *smi, u32 port, u32 reg, u32 *pData)
+{
+    int retVal;
+
+
+    if ((retVal = rtl8367c_getAsicPHYReg(smi, port, reg, pData)) != 0)
+        return retVal;
+
+    return 0;
+}
+
+u32 rtl8367c_setAsicPHYReg(struct rtl8366_smi *smi, u32 phyNo, u32 phyAddr, u32 phyData )
+{
+    u32 ocp_addr;
+
+
+    ocp_addr = 0xa400 + phyAddr*2;
+
+    return rtl8367c_setAsicPHYOCPReg(smi, phyNo, ocp_addr, phyData);
+}
+
+
+int dal_rtl8367c_port_phyReg_set(struct rtl8366_smi *smi, u32 port, u32 reg, u32 regData)
+{
+    int retVal;
+
+
+    if ((retVal = rtl8367c_setAsicPHYReg(smi, port, reg, regData)) != 0)
+        return retVal;
+
+    return 0;
+}
+
+
+static int rtl8367c_enable_port(struct rtl8366_smi *smi, int port, int enable)
+{
+    u32 data;
+	int err;
+   
+    REG_RWBT(smi, RTL8367C_REG_PHY_AD, RTL8367C_PDNPHY_OFFSET, !enable);
+
+
+	dal_rtl8367c_port_phyReg_get(smi, port, PHY_CONTROL_REG, &data);
+
+	if (ENABLED == enable)
+	{
+		data &= 0xF7FF;
+		data |= 0x0200;
+	}
+	else
+	{
+		data |= 0x0800;
+ 	}
+	dal_rtl8367c_port_phyReg_set(smi, (u32)port, PHY_CONTROL_REG, data);
+
+    return 0;
+}
+
+int rtl8367c_setAsicMIBsCounterReset(struct rtl8366_smi *smi, u32 greset, u32 qmreset, u32 portmask)
+{
+    int err;
+    u32 regData;
+    u32 regBits;
+
+    regBits = RTL8367C_GLOBAL_RESET_MASK |
+                RTL8367C_QM_RESET_MASK |
+                    RTL8367C_MIB_PORT07_MASK |
+                    ((u32)0x7 << 13);
+    regData = ((greset << RTL8367C_GLOBAL_RESET_OFFSET) & RTL8367C_GLOBAL_RESET_MASK) |
+                ((qmreset << RTL8367C_QM_RESET_OFFSET) & RTL8367C_QM_RESET_MASK) |
+                (((portmask & 0xFF) << RTL8367C_PORT0_RESET_OFFSET) & RTL8367C_MIB_PORT07_MASK) |
+                (((portmask >> 8)&0x7) << 13);
+
+
+    REG_RWBTS(smi, RTL8367C_REG_MIB_CTRL0, regBits, (regData >> RTL8367C_PORT0_RESET_OFFSET));
+
+    return 0;
+}
+
+
+
+static int rtl8367c_sw_reset_mibs(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	int err;
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	if ((err = rtl8367c_setAsicMIBsCounterReset(smi, 1,0, 0)) != 0)
+        return err;
+	return 0;
+}
+
+static int rtl8367c_sw_get_max_length(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	u32 data;
+
+	rtl8366_smi_read_reg(smi, RTL8367C_REG_MAX_LENGTH_LIMINT_IPG, &data);
+	val->value.i = (data & RTL8367C_MAX_LENTH_CTRL_MASK) >>
+			RTL8367C_SWC0_MAX_LENGTH_SHIFT;
+
+	return 0;
+}
+
+
+static int rtl8367c_sw_set_max_length(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	u32 max_len;
+	int err;
+
+	switch (val->value.i) {
+	case 0:
+		max_len = RTL8367C_SWC0_MAX_LENGTH_1522;
+		break;
+	case 1:
+		max_len = RTL8367C_SWC0_MAX_LENGTH_1536;
+		break;
+	case 2:
+		max_len = RTL8367C_SWC0_MAX_LENGTH_1552;
+		break;
+	case 3:
+		max_len = RTL8367C_SWC0_MAX_LENGTH_16000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	REG_RWBTS(smi, RTL8367C_REG_MAX_LENGTH_LIMINT_IPG,
+			        RTL8367C_MAX_LENTH_CTRL_MASK, max_len);
+	return 0;
+}
+
+static int rtl8367c_sw_reset_port_mibs(struct switch_dev *dev,
+				       const struct switch_attr *attr,
+				       struct switch_val *val)
+{
+	int err;
+    u32 phyPort;
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	
+	phyPort = val->port_vlan;
+	if (phyPort >= RTL8367C_NUM_PORTS)
+		return -EINVAL;
+
+    if ((err = rtl8367c_setAsicMIBsCounterReset(smi, 0,0,1 << phyPort)) != 0)
+		return err;
+
+    return 0;
+}
+
+
+
+
+/*
+static int rtl8367c_sw_get_port_stats(struct switch_dev *dev, int port,
+                                        struct switch_port_stats *stats)
+{
+	return (rtl8366_sw_get_port_stats(dev, port, stats,
+				RTL8367C_MIB_TXB_ID, RTL8367C_MIB_RXB_ID));
+}
+*/
+
+
+static int rtl8367c_sw_get_port_link(struct switch_dev *dev,
+				    int port,
+				    struct switch_port_link *link)
+{
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	u32 data = 0;
+	
+
+	rtl8367c_getAsicPHYReg(smi, port, PHY_RESOLVED_REG, &data);
+	
+	if (data & (1<<2))
+	{
+		link->link = 1;
+		link->duplex = 1;
+		link->aneg = 1;
+		link->rx_flow = 1;
+		link->tx_flow = 1;
+		data = (data&0x0030) >> 4;
+		switch (data) {
+			case 0x2:
+				link->speed = SWITCH_PORT_SPEED_1000;
+				break;
+				break;
+			case 0x01:
+				link->speed = SWITCH_PORT_SPEED_100;
+				break;
+				break;
+			case 0x00:
+				link->speed = SWITCH_PORT_SPEED_10;
+				break;
+				break;
+			default:
+				return -1;
+		}
+	}
+	else{
+		link->link = 0;
+		return 0;
+		}
+	return 0;
+}
+
+
+static struct switch_attr rtl8367c_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = rtl8366_sw_set_vlan_enable,
+		.get = rtl8366_sw_get_vlan_enable,
+		.max = 1,
+		.ofs = 1
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan4k",
+		.description = "Enable VLAN 4K mode",
+		.set = rtl8366_sw_set_vlan_enable,
+		.get = rtl8366_sw_get_vlan_enable,
+		.max = 1,
+		.ofs = 2
+	}, {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = rtl8367c_sw_reset_mibs,
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "max_length",
+		.description = "Get/Set the maximum length of valid packets"
+			       "(0:1522, 1:1536, 2:1552, 3:16000)",
+		.set = rtl8367c_sw_set_max_length,
+		.get = rtl8367c_sw_get_max_length,
+		.max = 3,
+	}
+};
+
+static struct switch_attr rtl8367c_port[] = {
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mib",
+		.description = "Reset single port MIB counters",
+		.set = rtl8367c_sw_reset_port_mibs,
+	}, {
+		.type = SWITCH_TYPE_STRING,
+		.name = "mib",
+		.description = "Get MIB counters for port",
+		.max = 33,
+		.set = NULL,
+		.get = rtl8366_sw_get_port_mib,
+	},
+};
+
+static struct switch_attr rtl8367c_vlan[] = {
+	{
+		.type = SWITCH_TYPE_STRING,
+		.name = "info",
+		.description = "Get vlan information",
+		.max = 1,
+		.set = NULL,
+		.get = rtl8366_sw_get_vlan_info,
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "fid",
+		.description = "Get/Set vlan FID",
+		.max = RTL8367C_FIDMAX,
+		.set = rtl8366_sw_set_vlan_fid,
+		.get = rtl8366_sw_get_vlan_fid,
+	},
+};
+
+static const struct switch_dev_ops rtl8367c_sw_ops = {
+	.attr_global = {
+		.attr = rtl8367c_globals,
+		.n_attr = ARRAY_SIZE(rtl8367c_globals),
+	},
+	.attr_port = {
+		.attr = rtl8367c_port,
+		.n_attr = ARRAY_SIZE(rtl8367c_port),
+	},
+	.attr_vlan = {
+		.attr = rtl8367c_vlan,
+		.n_attr = ARRAY_SIZE(rtl8367c_vlan),
+	},
+
+	.get_vlan_ports = rtl8366_sw_get_vlan_ports,
+	.set_vlan_ports = rtl8366_sw_set_vlan_ports,
+	.get_port_pvid = rtl8366_sw_get_port_pvid,
+	.set_port_pvid = rtl8366_sw_set_port_pvid,
+	.reset_switch = rtl8366_sw_reset_switch,
+	.get_port_link = rtl8367c_sw_get_port_link,
+	//.get_port_stats = rtl8367c_sw_get_port_stats,
+};
+		
+
+
+static int rtl8367c_switch_init(struct rtl8366_smi *smi)
+{
+	struct switch_dev *dev = &smi->sw_dev;
+	int err;
+
+	dev->name = "RTL8367C";
+	dev->cpu_port = RTL8367C_CPU_PORT_NUM;
+	dev->ports = RTL8367C_NUM_PORTS;
+	dev->vlans = RTL8367C_NUM_VIDS;
+	dev->ops = &rtl8367c_sw_ops;
+	dev->alias = dev_name(smi->parent);
+
+	err = register_switch(dev, NULL);
+	if (err)
+		dev_err(smi->parent, "switch registration failed\n");
+
+	return err;
+}
+
+static void rtl8367c_switch_cleanup(struct rtl8366_smi *smi)
+{
+	unregister_switch(&smi->sw_dev);
+}
+
+
+static struct rtl8366_smi_ops rtl8367c_smi_ops = {
+	.detect		= rtl8367c_detect,
+	.reset_chip	= rtl8367c_reset_chip,
+	.setup		= rtl8367c_setup,
+
+	.mii_read	= rtl8367c_mii_read,
+	.mii_write	= rtl8367c_mii_write,
+
+	.get_vlan_mc	= rtl8367c_get_vlan_mc,
+	.set_vlan_mc	= rtl8367c_set_vlan_mc,
+	.get_vlan_4k	= rtl8367c_get_vlan_4k,
+	.set_vlan_4k	= rtl8367c_set_vlan_4k,
+	.get_mc_index	= rtl8367c_get_mc_index,
+	.set_mc_index	= rtl8367c_set_mc_index,
+	.get_mib_counter = rtl8367c_get_mib_counter,
+	.is_vlan_valid	= rtl8367c_is_vlan_valid,
+	.enable_vlan	= rtl8367c_enable_vlan,
+	.enable_vlan4k	= rtl8367c_enable_vlan4k,
+	.enable_port	= rtl8367c_enable_port,
+};
+
+
+static int rtl8367c_probe(struct platform_device *pdev)
+{
+	struct rtl8366_smi *smi;
+	int err;
+
+	smi = rtl8366_smi_probe(pdev);
+	if (IS_ERR(smi))
+		return PTR_ERR(smi);
+
+	smi->clk_delay = 1500;
+	smi->cmd_read = 0xb9;
+	smi->cmd_write = 0xb8;
+	smi->ops = &rtl8367c_smi_ops;
+	smi->cpu_port = RTL8367C_CPU_PORT_NUM;
+	smi->num_ports = RTL8367C_NUM_PORTS;
+	smi->num_vlan_mc = RTL8367C_NUM_VLANS;
+	smi->mib_counters = rtl8367c_mib_counters;
+	smi->num_mib_counters = ARRAY_SIZE(rtl8367c_mib_counters);
+
+	err = rtl8366_smi_init(smi);
+	if (err)
+		goto err_free_smi;
+
+	platform_set_drvdata(pdev, smi);
+
+	err = rtl8367c_switch_init(smi);
+	if (err)
+		goto err_clear_drvdata;
+
+	return 0;
+
+ err_clear_drvdata:
+	platform_set_drvdata(pdev, NULL);
+	rtl8366_smi_cleanup(smi);
+ err_free_smi:
+	kfree(smi);
+	return err;
+}
+
+static int rtl8367c_remove(struct platform_device *pdev)
+{
+	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
+
+	if (smi) {
+		rtl8367c_switch_cleanup(smi);
+		platform_set_drvdata(pdev, NULL);
+		rtl8366_smi_cleanup(smi);
+		kfree(smi);
+	}
+
+	return 0;
+}
+
+static void rtl8367c_shutdown(struct platform_device *pdev)
+{
+	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
+
+	if (smi)
+		rtl8367c_reset_chip(smi);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id rtl8367c_match[] = {
+       { .compatible = "realtek,rtl8367c" },
+       {},
+};
+MODULE_DEVICE_TABLE(of, rtl8367c_match);
+#endif
+
+static struct platform_driver rtl8367c_driver = {
+	.driver = {
+		.name		= RTL8367C_DRIVER_NAME,
+		.owner		= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(rtl8367c_match),
+#endif
+	},
+	.probe		= rtl8367c_probe,
+	.remove		= rtl8367c_remove,
+	.shutdown	= rtl8367c_shutdown,
+};
+
+static int __init rtl8367c_module_init(void)
+{
+	return platform_driver_register(&rtl8367c_driver);
+}
+module_init(rtl8367c_module_init);
+
+static void __exit rtl8367c_module_exit(void)
+{
+	platform_driver_unregister(&rtl8367c_driver);
+}
+module_exit(rtl8367c_module_exit);
+
+MODULE_DESCRIPTION("Realtek RTL8367C ethernet switch driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" RTL8367C_DRIVER_NAME);
+
+
+
+
+
+
+
+
+
--- a/drivers/net/phy/rtl8366_smi.h	2023-03-21 09:29:19.422575683 +0800
+++ b/drivers/net/phy/rtl8366_smi.h	2023-03-20 08:55:48.041464368 +0800
@@ -14,6 +14,7 @@
 #include <linux/phy.h>
 #include <linux/switch.h>
 #include <linux/platform_device.h>
+#include <linux/reset.h>
 
 struct rtl8366_smi_ops;
 struct rtl8366_vlan_ops;
@@ -33,7 +34,7 @@ struct rtl8366_smi {
 	struct device		*parent;
 	unsigned int		gpio_sda;
 	unsigned int		gpio_sck;
-	void			(*hw_reset)(bool active);
+	void			(*hw_reset)(struct rtl8366_smi *smi, bool active);
 	unsigned int		clk_delay;	/* ns */
 	u8			cmd_read;
 	u8			cmd_write;
@@ -54,11 +55,16 @@ struct rtl8366_smi {
 	int			vlan4k_enabled;
 
 	char			buf[4096];
+
+	struct reset_control	*reset;
+
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
 	struct dentry           *debugfs_root;
 	u16			dbg_reg;
 	u8			dbg_vlan_4k_page;
 #endif
+	struct mii_bus		*ext_mbus;
+	u32 phy_addr;
 };
 
 struct rtl8366_vlan_mc {
@@ -109,6 +115,10 @@ int rtl8366_smi_write_reg(struct rtl8366
 int rtl8366_smi_write_reg_noack(struct rtl8366_smi *smi, u32 addr, u32 data);
 int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data);
 int rtl8366_smi_rmwr(struct rtl8366_smi *smi, u32 addr, u32 mask, u32 data);
+int rtl8366_smi_rwbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 value);
+int rtl8366_smi_rwbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 value);
+int rtl8366_smi_rdbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 *value);
+int rtl8366_smi_rdbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 *value);
 
 int rtl8366_reset_vlan(struct rtl8366_smi *smi);
 int rtl8366_enable_vlan(struct rtl8366_smi *smi, int enable);
@@ -146,6 +156,9 @@ int rtl8366_sw_get_vlan_enable(struct sw
 int rtl8366_sw_set_vlan_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val);
+int rtl8366_sw_get_port_stats(struct switch_dev *dev, int port,
+				struct switch_port_stats *stats,
+				int txb_id, int rxb_id);
 
 struct rtl8366_smi* rtl8366_smi_probe(struct platform_device *pdev);
 
--- a/drivers/net/phy/rtl8366_smi.c	2023-03-21 09:28:56.426383208 +0800
+++ b/drivers/net/phy/rtl8366_smi.c	2023-03-21 09:15:07.869753295 +0800
@@ -19,6 +19,8 @@
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
 #include <linux/rtl8366.h>
+#include <linux/version.h>
+#include <linux/of_mdio.h>
 
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
 #include <linux/debugfs.h>
@@ -197,7 +199,7 @@ static int rtl8366_smi_read_byte1(struct
 	return 0;
 }
 
-int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+static int __rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 {
 	unsigned long flags;
 	u8 lo = 0;
@@ -238,6 +240,101 @@ int rtl8366_smi_read_reg(struct rtl8366_
 
 	return ret;
 }
+/* Read/write via mdiobus */
+#define MDC_MDIO_CTRL0_REG		31
+#define MDC_MDIO_START_REG		29
+#define MDC_MDIO_CTRL1_REG		21
+#define MDC_MDIO_ADDRESS_REG		23
+#define MDC_MDIO_DATA_WRITE_REG		24
+#define MDC_MDIO_DATA_READ_REG		25
+
+#define MDC_MDIO_START_OP		0xFFFF
+#define MDC_MDIO_ADDR_OP		0x000E
+#define MDC_MDIO_READ_OP		0x0001
+#define MDC_MDIO_WRITE_OP		0x0003
+#define MDC_REALTEK_PHY_ADDR		0
+
+int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+{
+	u32 phy_id = smi->phy_addr?smi->phy_addr:MDC_REALTEK_PHY_ADDR;
+	struct mii_bus *mbus = smi->ext_mbus;
+
+	BUG_ON(in_interrupt());
+
+	mutex_lock(&mbus->mdio_lock);
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address control code to register 31 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address to register 23 */
+	mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write read control code to register 21 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_READ_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(smi->ext_mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Read data from register 25 */
+	*data = mbus->read(mbus, phy_id, MDC_MDIO_DATA_READ_REG);
+
+	mutex_unlock(&mbus->mdio_lock);
+
+	return 0;
+}
+
+static int __rtl8366_mdio_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
+{
+	u32 phy_id = smi->phy_addr?smi->phy_addr:MDC_REALTEK_PHY_ADDR;
+	struct mii_bus *mbus = smi->ext_mbus;
+
+	BUG_ON(in_interrupt());
+
+	mutex_lock(&mbus->mdio_lock);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address control code to register 31 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address to register 23 */
+	mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write data to register 24 */
+	mbus->write(mbus, phy_id, MDC_MDIO_DATA_WRITE_REG, data);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write data control code to register 21 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_WRITE_OP);
+
+	mutex_unlock(&mbus->mdio_lock);
+	return 0;
+}
+
+int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+{
+	if (smi->ext_mbus)
+		return __rtl8366_mdio_read_reg(smi, addr, data);
+	else
+		return __rtl8366_smi_read_reg(smi, addr, data);
+}
 EXPORT_SYMBOL_GPL(rtl8366_smi_read_reg);
 
 static int __rtl8366_smi_write_reg(struct rtl8366_smi *smi,
@@ -289,7 +386,10 @@ static int __rtl8366_smi_write_reg(struc
 
 int rtl8366_smi_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
 {
-	return __rtl8366_smi_write_reg(smi, addr, data, true);
+	if (smi->ext_mbus)
+		return __rtl8366_mdio_write_reg(smi, addr, data);
+	else
+		return __rtl8366_smi_write_reg(smi, addr, data, true);
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_write_reg);
 
@@ -314,12 +414,98 @@ int rtl8366_smi_rmwr(struct rtl8366_smi
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_rmwr);
 
+
+int rtl8366_smi_rwbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 value)
+{
+	u32 t;
+    int err;
+
+    err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    if(value)
+        t = t | (1 << bit);
+    else
+        t = t & (~(1 << bit));
+
+    err = rtl8366_smi_write_reg(smi, addr, t);
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rwbt);
+
+int rtl8366_smi_rdbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 *value)
+{
+	u32 t;
+    int err;
+
+	err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    *value = (t & (0x1 << bit)) >> bit;
+
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rdbt);
+
+
+int rtl8366_smi_rwbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 value)
+{
+	u32 t;
+    int err;
+	u32 bitsShift;
+	u32 valueShifted;
+	
+	bitsShift = 0;
+	while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+    }
+	valueShifted = value << bitsShift;
+
+    err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    t = t & (~bits);
+    t = t | (valueShifted & bits);
+
+    err = rtl8366_smi_write_reg(smi, addr, t);
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rwbts);
+
+int rtl8366_smi_rdbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 *value)
+{
+	u32 t;
+    int err;
+
+	u32 bitsShift;
+	
+	bitsShift = 0;
+	while(!(bits & (1 << bitsShift)))
+	{
+		bitsShift++;
+	}
+	
+	err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+	*value = (t & bits) >> bitsShift;
+
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rdbts);
+
+
+
 static int rtl8366_reset(struct rtl8366_smi *smi)
 {
 	if (smi->hw_reset) {
-		smi->hw_reset(true);
+		smi->hw_reset(smi, true);
 		msleep(RTL8366_SMI_HW_STOP_DELAY);
-		smi->hw_reset(false);
+		smi->hw_reset(smi, false);
 		msleep(RTL8366_SMI_HW_START_DELAY);
 		return 0;
 	}
@@ -914,7 +1100,12 @@ static inline void rtl8366_debugfs_remov
 static int rtl8366_smi_mii_init(struct rtl8366_smi *smi)
 {
 	int ret;
-	int i;
+
+#ifdef CONFIG_OF
+	struct device_node *np = NULL;
+
+	np = of_get_child_by_name(smi->parent->of_node, "mdio-bus");
+#endif
 
 	smi->mii_bus = mdiobus_alloc();
 	if (smi->mii_bus == NULL) {
@@ -930,11 +1121,14 @@ static int rtl8366_smi_mii_init(struct r
 		 dev_name(smi->parent));
 	smi->mii_bus->parent = smi->parent;
 	smi->mii_bus->phy_mask = ~(0x1f);
-	smi->mii_bus->irq = smi->mii_irq;
-	for (i = 0; i < PHY_MAX_ADDR; i++)
-		smi->mii_irq[i] = PHY_POLL;
 
-	ret = mdiobus_register(smi->mii_bus);
+#ifdef CONFIG_OF
+	if (np)
+		ret = of_mdiobus_register(smi->mii_bus, np);
+	else
+#endif
+		ret = mdiobus_register(smi->mii_bus);
+
 	if (ret)
 		goto err_free;
 
@@ -1025,6 +1219,33 @@ int rtl8366_sw_get_port_mib(struct switc
 }
 EXPORT_SYMBOL_GPL(rtl8366_sw_get_port_mib);
 
+int rtl8366_sw_get_port_stats(struct switch_dev *dev, int port,
+				struct switch_port_stats *stats,
+				int txb_id, int rxb_id)
+{
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	unsigned long long counter = 0;
+	int ret;
+
+	if (port >= smi->num_ports)
+		return -EINVAL;
+
+	ret = smi->ops->get_mib_counter(smi, txb_id, port, &counter);
+	if (ret)
+		return ret;
+
+	stats->tx_bytes = counter;
+
+	ret = smi->ops->get_mib_counter(smi, rxb_id, port, &counter);
+	if (ret)
+		return ret;
+
+	stats->rx_bytes = counter;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rtl8366_sw_get_port_stats);
+
 int rtl8366_sw_get_vlan_info(struct switch_dev *dev,
 			     const struct switch_attr *attr,
 			     struct switch_val *val)
@@ -1237,25 +1458,27 @@ static int __rtl8366_smi_init(struct rtl
 {
 	int err;
 
-	err = gpio_request(smi->gpio_sda, name);
-	if (err) {
-		printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
-			smi->gpio_sda, err);
-		goto err_out;
-	}
+	if (!smi->ext_mbus) {
+		err = gpio_request(smi->gpio_sda, name);
+		if (err) {
+			printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
+				smi->gpio_sda, err);
+			goto err_out;
+		}
 
-	err = gpio_request(smi->gpio_sck, name);
-	if (err) {
-		printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
-			smi->gpio_sck, err);
-		goto err_free_sda;
+		err = gpio_request(smi->gpio_sck, name);
+		if (err) {
+			printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
+				smi->gpio_sck, err);
+			goto err_free_sda;
+		}
 	}
 
 	spin_lock_init(&smi->lock);
 
 	/* start the switch */
 	if (smi->hw_reset) {
-		smi->hw_reset(false);
+		smi->hw_reset(smi, false);
 		msleep(RTL8366_SMI_HW_START_DELAY);
 	}
 
@@ -1270,10 +1493,12 @@ static int __rtl8366_smi_init(struct rtl
 static void __rtl8366_smi_cleanup(struct rtl8366_smi *smi)
 {
 	if (smi->hw_reset)
-		smi->hw_reset(true);
+		smi->hw_reset(smi, true);
 
-	gpio_free(smi->gpio_sck);
-	gpio_free(smi->gpio_sda);
+	if (!smi->ext_mbus) {
+		gpio_free(smi->gpio_sck);
+		gpio_free(smi->gpio_sda);
+	}
 }
 
 enum rtl8366_type rtl8366_smi_detect(struct rtl8366_platform_data *pdata)
@@ -1326,8 +1551,11 @@ int rtl8366_smi_init(struct rtl8366_smi
 	if (err)
 		goto err_out;
 
-	dev_info(smi->parent, "using GPIO pins %u (SDA) and %u (SCK)\n",
-		 smi->gpio_sda, smi->gpio_sck);
+	if (!smi->ext_mbus)
+		dev_info(smi->parent, "using GPIO pins %u (SDA) and %u (SCK)\n",
+			 smi->gpio_sda, smi->gpio_sck);
+	else
+		dev_info(smi->parent, "using MDIO bus '%s'\n", smi->ext_mbus->name);
 
 	err = smi->ops->detect(smi);
 	if (err) {
@@ -1380,18 +1608,62 @@ void rtl8366_smi_cleanup(struct rtl8366_
 EXPORT_SYMBOL_GPL(rtl8366_smi_cleanup);
 
 #ifdef CONFIG_OF
+static void rtl8366_smi_reset(struct rtl8366_smi *smi, bool active)
+{
+	if (active)
+		reset_control_assert(smi->reset);
+	else
+		reset_control_deassert(smi->reset);
+}
+
 int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi *smi)
 {
 	int sck = of_get_named_gpio(pdev->dev.of_node, "gpio-sck", 0);
 	int sda = of_get_named_gpio(pdev->dev.of_node, "gpio-sda", 0);
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *mdio_node;
+	const __be32 *phy_addr;
+	int len;
+	phy_addr = of_get_property(np, "phy-addr", &len);
+	if (!phy_addr || len != sizeof(uint32_t)) {
+		smi->phy_addr  = 0;
+	}else{
+		smi->phy_addr = be32_to_cpup(phy_addr);
+	}
+
+        dev_err(&pdev->dev, "phy addr = %x\n",smi->phy_addr);
+
+
+	mdio_node = of_parse_phandle(np, "mii-bus", 0);
+	if (!mdio_node) {
+		dev_err(&pdev->dev, "cannot find mdio node phandle");
+		goto try_gpio;
+	}
+
+	smi->ext_mbus = of_mdio_find_bus(mdio_node);
+	if (!smi->ext_mbus) {
+		dev_info(&pdev->dev,
+			"cannot find mdio bus from bus handle (yet)");
+		goto try_gpio;
+	}
 
+	return 0;
+
+try_gpio:
 	if (!gpio_is_valid(sck) || !gpio_is_valid(sda)) {
-		dev_err(&pdev->dev, "gpios missing in devictree\n");
-		return -EINVAL;
+		if (!mdio_node) {
+			dev_err(&pdev->dev, "gpios missing in devictree\n");
+			return -EINVAL;
+		} else {
+			return -EPROBE_DEFER;
+		}
 	}
 
 	smi->gpio_sda = sda;
 	smi->gpio_sck = sck;
+	smi->reset = devm_reset_control_get(&pdev->dev, "switch");
+	if (!IS_ERR(smi->reset))
+		smi->hw_reset = rtl8366_smi_reset;
 
 	return 0;
 }
@@ -1440,7 +1712,7 @@ struct rtl8366_smi *rtl8366_smi_probe(st
 
 free_smi:
 	kfree(smi);
-	return NULL;
+	return ERR_PTR(err);
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_probe);
 
--- a/include/linux/rtl8367c.h	2023-03-21 16:55:56.804646036 +0800
+++ b/include/linux/rtl8367c.h	2023-03-20 08:47:42.029723051 +0800
@@ -0,0 +1,163 @@
+#ifndef _RTL8367C_H
+#define _RTL8367C_H
+
+#define RTL8367C_DRIVER_NAME	"rtl8367C"
+
+enum rtl8367c_port_speed {
+	RTL8367_PORT_SPEED_10 = 0,
+	RTL8367_PORT_SPEED_100,
+	RTL8367_PORT_SPEED_1000,
+};
+
+struct rtl8367c_port_ability {
+	int force_mode;
+	int mstfault;
+    int mstmode;
+	int nway;
+	int txpause;
+	int rxpause;
+	int link;
+	int duplex;
+	enum rtl8367c_port_speed speed;
+};
+
+typedef struct  rtl8367c_rma_s{
+
+    u16 operation;
+    u16 discard_storm_filter;
+    u16 trap_priority;
+    u16 keep_format;
+    u16 vlan_leaky;
+    u16 portiso_leaky;
+
+}rtl8367c_rma_t;
+
+
+enum rtl8367c_extif_mode {
+	RTL8367C_EXT_DISABLE = 0,
+    RTL8367C_EXT_RGMII,
+    RTL8367C_EXT_MII_MAC,
+    RTL8367C_EXT_MII_PHY,
+    RTL8367C_EXT_TMII_MAC,
+    RTL8367C_EXT_TMII_PHY,
+    RTL8367C_EXT_GMII,
+    RTL8367C_EXT_RMII_MAC,
+    RTL8367C_EXT_RMII_PHY,
+    RTL8367C_EXT_SGMII,
+    RTL8367C_EXT_HSGMII,
+    RTL8367C_EXT_1000X_100FX,
+    RTL8367C_EXT_1000X,
+    RTL8367C_EXT_100FX,
+    RTL8367C_EXT_RGMII_2,
+    RTL8367C_EXT_MII_MAC_2,
+    RTL8367C_EXT_MII_PHY_2,
+    RTL8367C_EXT_TMII_MAC_2,
+    RTL8367C_EXT_TMII_PHY_2,
+    RTL8367C_EXT_RMII_MAC_2,
+    RTL8367C_EXT_RMII_PHY_2,
+};
+
+struct rtl8367c_extif_config {
+	unsigned int txdelay;
+	unsigned int rxdelay;
+	enum rtl8367c_extif_mode mode;
+	struct rtl8367c_port_ability ability;
+};
+
+struct rtl8367c_platform_data {
+	unsigned gpio_sda;
+	unsigned gpio_sck;
+	void (*hw_reset)(bool active);
+
+	struct rtl8367c_extif_config *extif0_cfg;
+	struct rtl8367c_extif_config *extif1_cfg;
+};
+
+typedef enum RTL8367C_MIBCOUNTER_E{
+
+    /* RX */
+    ifInOctets = 0,
+
+    dot3StatsFCSErrors,
+    dot3StatsSymbolErrors,
+    dot3InPauseFrames,
+    dot3ControlInUnknownOpcodes,
+
+    etherStatsFragments,
+    etherStatsJabbers,
+    ifInUcastPkts,
+    etherStatsDropEvents,
+
+    ifInMulticastPkts,
+    ifInBroadcastPkts,
+    inMldChecksumError,
+    inIgmpChecksumError,
+    inMldSpecificQuery,
+    inMldGeneralQuery,
+    inIgmpSpecificQuery,
+    inIgmpGeneralQuery,
+    inMldLeaves,
+    inIgmpLeaves,
+
+    /* TX/RX */
+    etherStatsOctets,
+
+    etherStatsUnderSizePkts,
+    etherOversizeStats,
+    etherStatsPkts64Octets,
+    etherStatsPkts65to127Octets,
+    etherStatsPkts128to255Octets,
+    etherStatsPkts256to511Octets,
+    etherStatsPkts512to1023Octets,
+    etherStatsPkts1024to1518Octets,
+
+    /* TX */
+    ifOutOctets,
+
+    dot3StatsSingleCollisionFrames,
+    dot3StatMultipleCollisionFrames,
+    dot3sDeferredTransmissions,
+    dot3StatsLateCollisions,
+    etherStatsCollisions,
+    dot3StatsExcessiveCollisions,
+    dot3OutPauseFrames,
+    ifOutDiscards,
+
+    /* ALE */
+    dot1dTpPortInDiscards,
+    ifOutUcastPkts,
+    ifOutMulticastPkts,
+    ifOutBroadcastPkts,
+    outOampduPkts,
+    inOampduPkts,
+
+    inIgmpJoinsSuccess,
+    inIgmpJoinsFail,
+    inMldJoinsSuccess,
+    inMldJoinsFail,
+    inReportSuppressionDrop,
+    inLeaveSuppressionDrop,
+    outIgmpReports,
+    outIgmpLeaves,
+    outIgmpGeneralQuery,
+    outIgmpSpecificQuery,
+    outMldReports,
+    outMldLeaves,
+    outMldGeneralQuery,
+    outMldSpecificQuery,
+    inKnownMulticastPkts,
+
+    /*Device only */
+    dot1dTpLearnedEntryDiscards,
+    RTL8367C_MIBS_NUMBER,
+
+}RTL8367C_MIBCOUNTER;
+
+typedef enum rtk_enable_e
+{
+    DISABLED = 0,
+    ENABLED,
+    RTK_ENABLE_END
+} rtk_enable_t;
+
+#endif /*  _RTL8367_H */
